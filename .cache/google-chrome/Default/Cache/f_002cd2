if (!('fold' in Array.prototype)) {
  Array.prototype.fold = function (accumulator, callback, context) {
    context = context || this;
    for (var i = 0; i < this.length; i++)
      accumulator = callback.call(context, this[i], accumulator, i);
    return accumulator;
  };
}

var logs = [];
if (typeof console != 'object') console = {};
if (typeof console.log != 'function') console.log = function () { logs.push(arguments); };

/** AsyncSpool
 *
 *  Simple helper for Worker
 */
var AsyncSpool = function () {
  this.pid = null;
  this.stack = [];
};

AsyncSpool.prototype.cooldown = function () {
  var self = this;
  return function () {
    while (self.stack.length > 0)
      self.stack.shift()();
    this.pid = null;
  }
};

AsyncSpool.prototype.push = function (callback) {
  if (! (callback instanceof Function)) return null;
  this.stack.push(callback);
  if (! this.pid) this.pid = setTimeout(this.cooldown(), 42);
  return this.pid;
};
/** Worker
 *
 *  seek
 *  start
 *  stop
 *  prepend
 *  flush
 *
 *
 */
var Worker = function (source, min, max) {
  this._min     = parseInt(min || 0);
  this._max     = parseInt(max || 1);
  this._source  = source;

  if (! isFinite(this._min) || ! isFinite(this._max))
    throw new Error('bad argument');
  if (! ('onupdate' in this._source))
    throw new Error('bad source');

  this._source.onupdate(this._onupdate());
  this.flush();
};

Worker.prototype.flush = function () {
  this._current  = null;
  this._running  = false;
  this._loading  = false;
  this._threads  = [];
  this._died     = [];
  this._burn     = null;
  this._deadtime = null;
};

Worker.prototype._onupdate = function () {
  var self = this;
  return function () {
    if (self._canPreload()) {
      self._append(this.next());
      self._sanitize();
    }
  };
};

Worker.prototype._canRetry = function () {
  return this._loading
    && this._deadtime != null
    && this._deadtime < (new Date).getTime();
};

Worker.prototype._canPreload = function () {
  if (this._source.length < 1) return false;
  var length = 0;
  if (this._current) length += (this._current.duration - this._current.past);
  for (var i = 0; i < this._threads.length; i++) {
    if (!(length < this._max)) return false;
    if (!this._threads[i].loaded) return false;
    length += this._threads[i].duration - this._threads[i].past;
  }
  return true;
};

Worker.prototype._trash = function (thread) {
  console.log('trash', (new Date).getTime(), (thread || { _song: { title: null } })._song.title);
  thread.pause();
//  thread.jump(0);
  if (thread == this._current) this._current = null;
//  this._died.push(thread);
  thread.destroy();
};

Worker.prototype._next = function () {
  if (this._running && this._threads.length) {
    this._current = this._threads.shift();
    if (! (this._current.duration > 0)) {
      /* console.log('qdssvasdv'); */
    }
    this._current.play();
  }
};

Worker.prototype._autoburn = function () {
  if (this._burn) {
    var b = this._burn;
    this._burn = null;
    this.seek(b.qt, b.nb);
  }
};

Worker.prototype._range = function () {
  var length = 0;
  for (var i = 0; i < this._threads.length; i++)
    if (this._threads[i].loaded)
      length += this._threads[i].duration;
    else
      break ;
  return length;
};

Worker.prototype._overload = (function () {
  var methods = ['onerror', 'onfinish', 'onprogress', 'onload'];
  var attributes = [{ key: 'flag', val: true }, { key: 'timeout', val: false }];
  return function (thread) {
    methods.fold(null, function (eventName) {
        if (eventName in thread) thread[eventName](this['_'+eventName](thread));
      }, this);
    attributes.fold(null, function (attr) {
      thread['__'+attr.key] = attr.val;
    }, this);
    this._loading = true;
    thread.preload();
    return thread;
  };
})();

Worker.prototype._success = function () {
  this._deadtime = null;
  this._loading  = false;
  this._timeout  = 1600;
};

Worker.prototype._failure = function (audiowrapper) {
  this._deadtime = (new Date).getTime() + this._timeout;
  this._loading  = true;
  if (this._current == audiowrapper) {
    //this._cleanCurrent();
    //alert('you win');
  }
  // PROD //  if (this._timeout < 20000) this._timeout *= 1.5;
};

// HANDLES - AudioWrapper.onload (when the sound is loaded)
Worker.prototype._onload = function (thread) {
  var self = this;
  return function (event) {
    /* console.log('file loaded: ', event.jPlayer.status.duration * 1000); */
    thread.duration = event.jPlayer.status.duration * 1000;
    /* console.log(self._range(), self._max); */
    //$('#buffer-status').text((((self._range() / self._max) * 100) | 0)+'%');
    self._success();
    self._autoburn();
    self._sanitize();
  };
};

// HANDLES - AudioWrapper.onfinish (when the sound has finished to play)
Worker.prototype._onfinish = function (thread) {
  var self = this;
  return function () {
    console.log('finish');
    //self._trash(thread);
    //self._sanitize();
  };
};

// HANDLES - AudioWrapper.onprogress (periodicly, when the sound is playing)
Worker.prototype._onprogress = function (thread) {
  var self = this;
  return function (event) {
    if (!thread._playing) return ;

    thread.past = event.jPlayer.status.currentTime * 1000;
    thread.duration = event.jPlayer.status.duration * 1000;

    var range = self._range();
    var rest  = range
    if (self._current) rest += thread.duration - thread.past;
    var ratio = Math.round(rest / self._max * 100);

    $('#buffer-status').text(ratio + '%');
//    $('.jp-play-bar').text(Math.round(thread.past)+'--'+Math.round(thread.duration));

    if (!thread.__timeout && (thread.past > thread.duration - 5000)) {
      thread.__timeout = setTimeout(function () {
        self._threads[0].play();
        self._trash(self._current);
        self._sanitize();
        console.log('nexted');
      }, thread.duration - thread.past + 400);
      console.log('end of song', thread, thread.__timeout, thread.duration, thread.past);
    } else if ((thread.__flag || self._canRetry()) || ratio < 100) {
      thread.__flag = false;
      self._sanitize();
    } else if (ratio > 100) {
      thread.__flag = true;
    }
  };
};

// HANDLES - AudioWrapper.onerror (when an error occurs)
Worker.prototype._onerror = function (thread) {
  var self = this;
  return function () {
    console.log('file loading failed', thread._song);
    self._failure(this);
    this.reset();
  };
};

Worker.prototype._append = function (thread) {
  if (thread instanceof Object)
    this._threads.push(this._overload(thread));
  else return false;
  return true;
};

Worker.prototype._cleanCurrent = function () {
  if (!this._current) return ;
  this._threads.unshift(this._current);
  this._current = null;
};

// check if the end of playlist
Worker.prototype._checkEOP = function () {
  if (! this._current && ! (this._threads.length > 0))
    console.log('eop');
};

Worker.prototype._gc = function () {
  var length = 0;
  for (var i = 0; i < this._died.length; i++) {
    if (length < this._min) length += this._died[i].duration;
    else break ;
  }
  this._died = this._died.slice(i);
};

/*
Worker.prototype._keepAlive = function () {
  if (this._pid) return ;
  var self = this;
  this._pid = setTimeout(function () {
    self._pid = null;
    if (! self._playing) return ;
    if (self._current && ! (self._current.duration > 0))
      self._cleanCurrent();
    self._sanitize();
  }, 2000);
};
*/

Worker.prototype._sanitize = function () {
  /* console.log('sanitize'); */
  var length = 0;
  if (!this._current) this._next();
  if (this._canRetry()) {
    this._deadtime = null;
    console.log('sanitize: retry');
    if (this._threads.length > 0)
      this._threads[this._threads.length - 1].preload();
    else if (this._current)
      this._current.preload();
  } else if (this._canPreload()) {
    if (this._current)
      length += this._current.duration - this._current.past;
    length += this._range();
    if (length < this._max) {
      var file = this._source.next();
      console.log('preloading:', file._song);
      this._append(file);
    }
  }
  this._gc();
  this._checkEOP();
  //this._keepAlive();
};

Worker.prototype.prepend = function (thread) {
  this._overload(thread);
  if (this.threads.length > 0) this.threads[0].seek(0);
  this.threads.unshift(thread);
};

Worker.prototype.start = function () {
  this._running = true;
  if (this._threads.length <= 0) return false;
  if (this._current) return true;
  this._next();
  this._current.play();
  this._current.__flag = true;
  this._current.__timeout = null;
  return true;
};

Worker.prototype.stop = function () {
  if (this._current) this._current.pause();
  if (this._threads.length > 0) this._threads[0].pause();
  this._running = false;
  this._cleanCurrent();
};

Worker.prototype.seek = function (quantity, nbThread) {
  if (!(isFinite(quantity) && isFinite(nbThread)))
    throw new Error('bad argument');
  if (nbThread < 0 || (quantity < 0 && nbThread == 0))
    this._restore(Math.abs(quantity), Math.abs(nbThread));

  this._cleanCurrent();
  while (42) {
    if (!(this._threads.length > 0)) {
      if (!this._append(this._source.next())) break ;
      this._burn = { qt: quantity, nb: nbThread };
      break ;
    }
    if (nbThread > 0) {
      this._trash(this._threads.shift());
      nbThread--;
      continue ;
    }
    if (quantity > 0) {
      var thread = this._threads[0];
      if (!thread.loaded) {
        this._burn = { qt: quantity, nb: 0 };
        break ;
      }
      if ((thread.duration - thread.past) < quantity) {
        quantity -= (thread.duration - thread.past);
        this._trash(this._threads.shift());
        continue ;
      }
      thread.jump(quantity + thread.past);
    }
    break ;
  }
  this._next();
  this._checkEOP();
};

/** AudioWrapper
 *
 *  loaded
 *  onerror
 *  reset
 *  jump
 *  onfinish
 *  onload
 *  onprogress
 *  pause
 *  play
 *  preload
 */
var AudioWrapper = function (song) {
  this._song       = song;
  this._playing    = false;
  this._callbacks  = { error: []
                     , progress: []
                     , load: [function () { this.loaded = true; }]
                     , finish: []
                     , update: [function (e) { console.log(e); }]
                     };

  this.loaded      = false;
  this.config      = this._config();
  this.duration    = 0;
  this.past        = 0;

  this._initialize();
};

AudioWrapper.prototype._initialize = function () {
  this._jquery = $(document.createElement('div'));

  var self = this;
  $(function () { $('body').append(self._jquery); });

  var time = '&at='+(new Date).getTime();
  this._jquery
    .jPlayer(this.config)
    .jPlayer('setMedia', { mp3: this._song.mp3+time, oga: this._song.oga+time })
};

AudioWrapper.prototype._config = function () {
  return { swfPath: 'jPlayer-2.0.0'
         , solution: 'html, flash'
//           , solution: 'flash, html'
         , supplied: 'oga, mp3'
         , preload: 'none'
         , volume: 1
         , muted: false
         , cssSelectorAncestor: '#notfound'
         , backgroundColor: 'transparent'
         , progress: this._onloadstep()
         , loadeddata: this._forall(this._callbacks.load)
         , error: this._forall(this._callbacks.error)
         , timeupdate: this._forall( this._callbacks.progress)
         , stalled: function () { alert('stalled'); }
         , ended: this._forall(this._callbacks.finish)
         , durationchange: this._forall(this._callbacks.update)
         , errorAlerts: false
         , warningAlerts: false
         };
};

AudioWrapper.prototype._forall = function (array) {
  var self = this;
  return function () {
    for (var i = 0; i < array.length; i++)
      array[i].apply(self, arguments);
  };
};
/*
AudioWrapper.prototype._refresh = function () {
  //console.log(this._song.title);
  $('#jp-status').text((this._playing ? 'playing' : 'stoped')+' title: '+this._song.title);
};
*/
AudioWrapper.prototype.play = function (e) {
  if (this._playing) return this;
  console.log('play', this._jquery.data('jPlayer').status.duration);
  this._jquery.jPlayer('play');
  this._playing = true;
  return this;
};

AudioWrapper.prototype.pause = function () {
  this._jquery.jPlayer('pause', this._song);
  this._playing = false;
  return this;
};

AudioWrapper.prototype.jump = function (position) {
  //console.log('jump', this._song);
  if (this.duration <= 0) throw new Error('song not loaded');
  this._jquery.jPlayer('playHead', position / this.duration * 100);
  if (!this._playing) this._jquery.jPlayer('pause');
  return this;
};

AudioWrapper.prototype.reset = function () {
  //console.log('reset', this._song);
  this.destroy();
  this._initialize();
  return this;
};

AudioWrapper.prototype.destroy = function () {
  //console.log('destroy', this._song);
  this._jquery.jPlayer('clearMedia');
  this._jquery.empty();
  this._jquery.get(0).parentNode.removeChild(this._jquery.get(0));
  return this;
};

AudioWrapper.prototype.preload = function () {
  console.log('preload', this._song);
  this._jquery.jPlayer('load');
  return this;
};

/* EVENTS */
AudioWrapper.prototype._onloadstep = function () {
  var self = this;
  return function (event) {
    if (event.jPlayer.status.duration * 1000 > self.duration)
      self.duration = event.jPlayer.status.duration * 1000;
  };
};

AudioWrapper.prototype.onerror = function (callback) {
  this._callbacks.error.push(callback);
  return this;
};

AudioWrapper.prototype.onfinish = function (callback) {
  this._callbacks.finish.push(callback);
  return this;
};

AudioWrapper.prototype.onprogress = function (callback) {
  this._callbacks.progress.push(callback);
  return this;
};

AudioWrapper.prototype.onload = function (callback) {
  this._callbacks.load.push(callback);
  return this;
};

// #### History
var History = function () {}

/** Spool
 *
 *  length
 *  onupdate
 *  insert
 *  prepare
 *
 */
var Spool = function (prepare) {
  if (prepare instanceof Function)
    this.prepare = prepare;

  this._begin    = [];
  this._end      = [];
  this._onupdate = [];
  this.length    = 0;

  return this;
};

Spool.prototype.insert = function (item, index) {
  if (index == 0) {
    this._begin.unshift(item);
  } else if (index < this._begin.length) {
    this._end = this._begin.slice(index).concat(this._end);
    this._begin = this._begin.slice(0, index).concat([item]);
  } else if (index == this._begin.length) {
    this._begin.push(item);
  } else if (index < this._begin.length + this._end.length) {
    var decal = index - this._begin.length;
    this._begin = this._begin.concat(this._end.slice(0, decal));
    this._end = [item].concat(this._end.slice(decal));
  } else {
    this._end.push(item);
  }
  this._length();
  this._trigger();
  return this;
};

Spool.prototype.next = function () {
  var item;
  if (this._begin.length > 0) item = this._begin.shift();
  else if (this._end > 0) item = this._end.shift();
  this._length();
  return item ? this.prepare(item) : null;
};

Spool.prototype.onupdate = function (callback) {
  this._onupdate.push(callback);
  return this;
};

Spool.prototype.prepare = function (alpha) {
  return alpha;
};

Spool.prototype._trigger = function () {
  for (var i = 0; i < this._onupdate.length; i++)
    this._onupdate[i].call(this);
};

Spool.prototype._length = function () {
  this.length = this._begin.length + this._end.length;
  return this.length;
};

/** Manager
 *
 *  run
 *  pause
 *  add
 *  forward
 *  rewind
 *  autoskip
 */
var Manager = function (preload, cache) {
  this._spool   = new Spool(this._prepare());
  this._history = new History;
  this._worker  = new Worker(this._spool, cache, preload);
  this._exec    = new AsyncSpool;

  return this;
};

Manager.prototype._prepare = function () {
  return function (item) {
    if (item.type == 'audio') var result = new AudioWrapper(item);
    else throw new Error('not implemented');
    return result;
  }
};

Manager.prototype.autoskip = true;

Manager.prototype.add = function (item, position) {
  if (!(item instanceof Object)) throw new Error('bad argument');
  if ('oga' in item || 'mp3' in item) item.type = 'audio';
  else if ('ogv' in item || 'mp4' in item) item.type = 'video';
  else throw new Error('unknow type');

  var self = this;
//  console.log(item.oga);
  this._exec.push(function () {
//    console.log(item.oga);

    var index = parseInt(position);
    if (isNaN(index)) switch (''+position) {
    default: index = self._spool.length; break ;
    case 'begin': index = -1; break ;
    }

    if (!isFinite(index)) throw new Error('bad position');
    if (index >= 0) self._spool.insert(item, index);
    else self._worker.prepend(self._spool.prepare(item));
  });

  return this;
};

Manager.prototype.run = function () {
//  alert(42);
  var self = this;
  $(function () { self._worker.start(); });
  return this;
};

Manager.prototype.pause = function () {
  var self = this;
  $(function () { self._worker.stop(); });
  return this;
};

Manager.prototype.forward = function (quantity, nbEntity) {
  this._worker.seek(Math.abs(quantity) || 0, Math.abs(nbEntity) || 0);
  return this;
};

Manager.prototype.rewind = function (quantity, nbEntity) {
  this._worker.seek((Math.abs(quantity) * -1) || 0, (Math.abs(nbEntity) * -1) || 0);
  return this;
};
