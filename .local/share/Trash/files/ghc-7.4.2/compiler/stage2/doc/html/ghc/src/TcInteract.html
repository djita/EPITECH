<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://www.cs.york.ac.uk/fp/darcs/hscolour/ -->
<title>typecheck/TcInteract.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>{-# OPTIONS -fno-warn-tabs #-}</span>
<a name="line-2"></a><span class='hs-comment'>-- The above warning supression flag is a temporary kludge.</span>
<a name="line-3"></a><span class='hs-comment'>-- While working on this module you are encouraged to remove it and</span>
<a name="line-4"></a><span class='hs-comment'>-- detab the module (please do the detabbing in a separate patch). See</span>
<a name="line-5"></a><span class='hs-comment'>--     <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces">http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces</a></span>
<a name="line-6"></a><span class='hs-comment'>-- for details</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcInteract</span> <span class='hs-layout'>(</span> 
<a name="line-9"></a>     <span class='hs-varid'>solveInteractWanted</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- Solves [WantedEvVar]</span>
<a name="line-10"></a>     <span class='hs-varid'>solveInteractGiven</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- Solves [EvVar],GivenLoc</span>
<a name="line-11"></a>     <span class='hs-varid'>solveInteractCts</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- Solves [Cts]</span>
<a name="line-12"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>  
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-15"></a>
<a name="line-16"></a>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span> <span class='hs-conid'>()</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcCanonical</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unify</span>
<a name="line-22"></a>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Id</span> 
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span> <span class='hs-layout'>(</span> <span class='hs-layout'>)</span> <span class='hs-comment'>-- unitVarEnv, mkInScopeSet</span>
<a name="line-26"></a>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-28"></a>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>IParam</span>
<a name="line-33"></a>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FunDeps</span>
<a name="line-35"></a>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-38"></a>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnTypes</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcErrors</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Maybes</span><span class='hs-layout'>(</span> <span class='hs-varid'>orElse</span> <span class='hs-layout'>)</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-44"></a>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span> <span class='hs-varid'>foldM</span> <span class='hs-layout'>)</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TrieMap</span>
<a name="line-47"></a>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Traversable</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Traversable</span>
<a name="line-50"></a>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-layout'>(</span> <span class='hs-varid'>when</span> <span class='hs-layout'>)</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pair</span> <span class='hs-layout'>(</span> <span class='hs-varid'>pSnd</span> <span class='hs-layout'>)</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>UniqFM</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span> <span class='hs-layout'>(</span> <span class='hs-varid'>sLit</span> <span class='hs-layout'>)</span> 
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
</pre>\end{code}
**********************************************************************
*                                                                    * 
*                      Main Interaction Solver                       *
*                                                                    *
**********************************************************************

Note [Basic Simplifier Plan] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Pick an element from the WorkList if there exists one with depth 
   less thanour context-stack depth. 

2. Run it down the 'stage' pipeline. Stages are: 
      - canonicalization
      - inert reactions
      - spontaneous reactions
      - top-level intreactions
   Each stage returns a StopOrContinue and may have sideffected 
   the inerts or worklist.
  
   The threading of the stages is as follows: 
      - If (Stop) is returned by a stage then we start again from Step 1. 
      - If (ContinueWith ct) is returned by a stage, we feed 'ct' on to 
        the next stage in the pipeline. 
4. If the element has survived (i.e. ContinueWith x) the last stage 
   then we add him in the inerts and jump back to Step 1.

If in Step 1 no such element exists, we have exceeded our context-stack 
depth and will simply fail.
\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><a name="solveInteractCts"></a><span class='hs-definition'>solveInteractCts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-3"></a><span class='hs-definition'>solveInteractCts</span> <span class='hs-varid'>cts</span> 
<a name="line-4"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>evvar_cache</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSEvVarCacheMap</span>
<a name="line-5"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cts_thinner</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_evvar_cache</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>add_cts_in_cache</span> <span class='hs-varid'>evvar_cache</span> <span class='hs-varid'>cts</span>
<a name="line-6"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveInteractCts"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"cts_original ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cts</span><span class='hs-layout'>,</span> 
<a name="line-7"></a>                                             <span class='hs-varid'>text</span> <span class='hs-str'>"cts_thinner  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cts_thinner</span>
<a name="line-8"></a>                                           <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-9"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setTcSEvVarCacheMap</span> <span class='hs-varid'>new_evvar_cache</span> 
<a name="line-10"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>appendWorkListCt</span> <span class='hs-varid'>cts_thinner</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>solveInteract</span> <span class='hs-layout'>}</span>
<a name="line-11"></a> 
<a name="line-12"></a>  <span class='hs-keyword'>where</span>
<a name="line-13"></a>    <span class='hs-varid'>add_cts_in_cache</span> <span class='hs-varid'>evvar_cache</span> <span class='hs-varid'>cts</span>
<a name="line-14"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSContext</span>
<a name="line-15"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>foldM</span> <span class='hs-layout'>(</span><span class='hs-varid'>solve_or_cache</span> <span class='hs-layout'>(</span><span class='hs-varid'>simplEqsOnly</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-varid'>evvar_cache</span><span class='hs-layout'>)</span> <span class='hs-varid'>cts</span> <span class='hs-layout'>}</span>
<a name="line-16"></a>
<a name="line-17"></a>    <span class='hs-varid'>solve_or_cache</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>    <span class='hs-comment'>-- Solve equalities only, not classes etc</span>
<a name="line-18"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>TypeMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvVar</span><span class='hs-layout'>,</span><span class='hs-conid'>CtFlavor</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-19"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span>
<a name="line-20"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>TypeMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvVar</span><span class='hs-layout'>,</span><span class='hs-conid'>CtFlavor</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-21"></a>    <span class='hs-varid'>solve_or_cache</span> <span class='hs-varid'>eqs_only</span> <span class='hs-layout'>(</span><span class='hs-varid'>acc_cts</span><span class='hs-layout'>,</span><span class='hs-varid'>acc_cache</span><span class='hs-layout'>)</span> <span class='hs-varid'>ct</span>
<a name="line-22"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dont_cache</span> <span class='hs-varid'>eqs_only</span> <span class='hs-layout'>(</span><span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred_ty</span><span class='hs-layout'>)</span>
<a name="line-23"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-conop'>:</span><span class='hs-varid'>acc_cts</span><span class='hs-layout'>,</span><span class='hs-varid'>acc_cache</span><span class='hs-layout'>)</span>
<a name="line-24"></a>
<a name="line-25"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev'</span><span class='hs-layout'>,</span><span class='hs-varid'>fl'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupTM</span> <span class='hs-varid'>pred_ty</span> <span class='hs-varid'>acc_cache</span>
<a name="line-26"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>fl'</span> <span class='hs-varop'>`canSolve`</span> <span class='hs-varid'>fl</span>
<a name="line-27"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isWanted</span> <span class='hs-varid'>fl</span>
<a name="line-28"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEvBind</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvId</span> <span class='hs-varid'>ev'</span><span class='hs-layout'>)</span> <span class='hs-varid'>fl</span>
<a name="line-29"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>acc_cts</span><span class='hs-layout'>,</span><span class='hs-varid'>acc_cache</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-30"></a>
<a name="line-31"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-comment'>-- If it's a given keep it in the work list, even if it exists in the cache!</span>
<a name="line-32"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-conop'>:</span><span class='hs-varid'>acc_cts</span><span class='hs-layout'>,</span> <span class='hs-varid'>alterTM</span> <span class='hs-varid'>pred_ty</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev</span><span class='hs-layout'>,</span><span class='hs-varid'>fl</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc_cache</span><span class='hs-layout'>)</span>
<a name="line-33"></a>      <span class='hs-keyword'>where</span> <span class='hs-varid'>fl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-varid'>ct</span>
<a name="line-34"></a>            <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_id</span> <span class='hs-varid'>ct</span>
<a name="line-35"></a>            <span class='hs-varid'>pred_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span>
<a name="line-36"></a>
<a name="line-37"></a>    <span class='hs-varid'>dont_cache</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredTree</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-38"></a>    <span class='hs-comment'>-- Do not use the cache, not update it, if this is true</span>
<a name="line-39"></a>    <span class='hs-varid'>dont_cache</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>IPPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>    <span class='hs-comment'>-- IPPreds have subtle shadowing</span>
<a name="line-40"></a>    <span class='hs-varid'>dont_cache</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>EqPred</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Report Int ~ Bool errors separately</span>
<a name="line-41"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tc1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConAppTyCon_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-42"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tc2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConAppTyCon_maybe</span> <span class='hs-varid'>ty2</span>
<a name="line-43"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>tc2</span>
<a name="line-44"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isDecomposableTyCon</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isDecomposableTyCon</span> <span class='hs-varid'>tc2</span>
<a name="line-45"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-46"></a>    <span class='hs-varid'>dont_cache</span> <span class='hs-varid'>eqs_only</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqs_only</span>
<a name="line-47"></a>            <span class='hs-comment'>-- If we are simplifying equalities only,</span>
<a name="line-48"></a>            <span class='hs-comment'>-- do not cache non-equalities</span>
<a name="line-49"></a>            <span class='hs-comment'>-- See Note [Simplifying RULE lhs constraints] in TcSimplify</span>
<a name="line-50"></a>
<a name="line-51"></a><a name="solveInteractGiven"></a><span class='hs-definition'>solveInteractGiven</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GivenLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span> 
<a name="line-52"></a><span class='hs-definition'>solveInteractGiven</span> <span class='hs-varid'>gloc</span> <span class='hs-varid'>evs</span>
<a name="line-53"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mk_noncan</span> <span class='hs-varid'>evs</span><span class='hs-layout'>)</span>
<a name="line-54"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>mk_noncan</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-55"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Given</span> <span class='hs-varid'>gloc</span> <span class='hs-conid'>GivenOrig</span> 
<a name="line-56"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span>
<a name="line-57"></a>
<a name="line-58"></a><a name="solveInteractWanted"></a><span class='hs-definition'>solveInteractWanted</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>WantedEvVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-59"></a><span class='hs-comment'>-- Solve these wanteds along with current inerts and wanteds!</span>
<a name="line-60"></a><span class='hs-definition'>solveInteractWanted</span> <span class='hs-varid'>wevs</span>
<a name="line-61"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mk_noncan</span> <span class='hs-varid'>wevs</span><span class='hs-layout'>)</span> 
<a name="line-62"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>mk_noncan</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvVarX</span> <span class='hs-varid'>v</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span> 
<a name="line-63"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Wanted</span> <span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span>
<a name="line-64"></a>
<a name="line-65"></a>
<a name="line-66"></a><a name="solveInteract"></a><span class='hs-comment'>-- The main solver loop implements Note [Basic Simplifier Plan]</span>
<a name="line-67"></a><span class='hs-comment'>---------------------------------------------------------------</span>
<a name="line-68"></a><span class='hs-definition'>solveInteract</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-69"></a><span class='hs-comment'>-- Returns the final InertSet in TcS, WorkList will be eventually empty.</span>
<a name="line-70"></a><span class='hs-definition'>solveInteract</span>
<a name="line-71"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "solveInteract" #-}</span>
<a name="line-72"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dyn_flags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-73"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>max_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxtStkDepth</span> <span class='hs-varid'>dyn_flags</span>
<a name="line-74"></a>             <span class='hs-varid'>solve_loop</span>
<a name="line-75"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "solve_loop" #-}</span>
<a name="line-76"></a>                <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>selectNextWorkItem</span> <span class='hs-varid'>max_depth</span>
<a name="line-77"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>sel</span> <span class='hs-keyword'>of</span> 
<a name="line-78"></a>                      <span class='hs-conid'>NoWorkRemaining</span>     <span class='hs-comment'>-- Done, successfuly (modulo frozen)</span>
<a name="line-79"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-80"></a>                      <span class='hs-conid'>MaxDepthExceeded</span> <span class='hs-varid'>ct</span> <span class='hs-comment'>-- Failure, depth exceeded</span>
<a name="line-81"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>solverDepthErrorTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_depth</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ct</span><span class='hs-keyglyph'>]</span>
<a name="line-82"></a>                      <span class='hs-conid'>NextWorkItem</span> <span class='hs-varid'>ct</span>     <span class='hs-comment'>-- More work, loop around!</span>
<a name="line-83"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>runSolverPipeline</span> <span class='hs-varid'>thePipeline</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>solve_loop</span> <span class='hs-layout'>}</span>
<a name="line-84"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solve_loop</span> <span class='hs-layout'>}</span>
<a name="line-85"></a>
<a name="line-86"></a><a name="WorkItem"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Ct</span>
<a name="line-87"></a><a name="SimplifierStage"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>SimplifierStage</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-88"></a>
<a name="line-89"></a><a name="continueWith"></a><span class='hs-definition'>continueWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-90"></a><span class='hs-definition'>continueWith</span> <span class='hs-varid'>work_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>work_item</span><span class='hs-layout'>)</span> 
<a name="line-91"></a>
<a name="line-92"></a><a name="SelectWorkItem"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>SelectWorkItem</span> 
<a name="line-93"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoWorkRemaining</span>      <span class='hs-comment'>-- No more work left (effectively we're done!)</span>
<a name="line-94"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MaxDepthExceeded</span> <span class='hs-conid'>Ct</span>  <span class='hs-comment'>-- More work left to do but this constraint has exceeded</span>
<a name="line-95"></a>                              <span class='hs-comment'>-- the max subgoal depth and we must stop </span>
<a name="line-96"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NextWorkItem</span> <span class='hs-conid'>Ct</span>      <span class='hs-comment'>-- More work left, here's the next item to look at </span>
<a name="line-97"></a>
<a name="line-98"></a><a name="selectNextWorkItem"></a><span class='hs-definition'>selectNextWorkItem</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SubGoalDepth</span> <span class='hs-comment'>-- Max depth allowed</span>
<a name="line-99"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SelectWorkItem</span>
<a name="line-100"></a><span class='hs-definition'>selectNextWorkItem</span> <span class='hs-varid'>max_depth</span>
<a name="line-101"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updWorkListTcS_return</span> <span class='hs-varid'>pick_next</span>
<a name="line-102"></a>  <span class='hs-keyword'>where</span> 
<a name="line-103"></a>    <span class='hs-varid'>pick_next</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WorkList</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>SelectWorkItem</span><span class='hs-layout'>,</span> <span class='hs-conid'>WorkList</span><span class='hs-layout'>)</span>
<a name="line-104"></a>    <span class='hs-varid'>pick_next</span> <span class='hs-varid'>wl</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>selectWorkItem</span> <span class='hs-varid'>wl</span> <span class='hs-keyword'>of</span>
<a name="line-105"></a>                     <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> 
<a name="line-106"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>NoWorkRemaining</span><span class='hs-layout'>,</span><span class='hs-varid'>wl</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- No more work</span>
<a name="line-107"></a>                     <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_wl</span><span class='hs-layout'>)</span> 
<a name="line-108"></a>                         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>cc_depth</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>max_depth</span>         <span class='hs-comment'>-- Depth exceeded</span>
<a name="line-109"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>MaxDepthExceeded</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span><span class='hs-varid'>new_wl</span><span class='hs-layout'>)</span>
<a name="line-110"></a>                     <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_wl</span><span class='hs-layout'>)</span> 
<a name="line-111"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>NextWorkItem</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_wl</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- New workitem and worklist</span>
<a name="line-112"></a>
<a name="line-113"></a><a name="runSolverPipeline"></a><span class='hs-definition'>runSolverPipeline</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>String</span><span class='hs-layout'>,</span><span class='hs-conid'>SimplifierStage</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- The pipeline </span>
<a name="line-114"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WorkItem</span>                   <span class='hs-comment'>-- The work item </span>
<a name="line-115"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span> 
<a name="line-116"></a><span class='hs-comment'>-- Run this item down the pipeline, leaving behind new work and inerts</span>
<a name="line-117"></a><span class='hs-definition'>runSolverPipeline</span> <span class='hs-varid'>pipeline</span> <span class='hs-varid'>workItem</span> 
<a name="line-118"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>initial_is</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span> 
<a name="line-119"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Start solver pipeline {"</span> <span class='hs-varop'>$</span> 
<a name="line-120"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"work item = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span> 
<a name="line-121"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"inerts    = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>initial_is</span><span class='hs-keyglyph'>]</span>
<a name="line-122"></a>
<a name="line-123"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>final_res</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>run_pipeline</span> <span class='hs-varid'>pipeline</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-124"></a>
<a name="line-125"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>final_is</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-126"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>final_res</span> <span class='hs-keyword'>of</span> 
<a name="line-127"></a>           <span class='hs-conid'>Stop</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"End solver pipeline (discharged) }"</span> 
<a name="line-128"></a>                                       <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"inerts    = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_is</span><span class='hs-layout'>)</span>
<a name="line-129"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-130"></a>           <span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"End solver pipeline (not discharged) }"</span> <span class='hs-varop'>$</span>
<a name="line-131"></a>                                       <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"final_item = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span>
<a name="line-132"></a>                                            <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"inerts     = "</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_is</span><span class='hs-keyglyph'>]</span>
<a name="line-133"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>updInertSetTcS</span> <span class='hs-varid'>ct</span> <span class='hs-layout'>}</span>
<a name="line-134"></a>       <span class='hs-layout'>}</span>
<a name="line-135"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>run_pipeline</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>String</span><span class='hs-layout'>,</span><span class='hs-conid'>SimplifierStage</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StopOrContinue</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-136"></a>        <span class='hs-varid'>run_pipeline</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res</span> 
<a name="line-137"></a>        <span class='hs-varid'>run_pipeline</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Stop</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> 
<a name="line-138"></a>        <span class='hs-varid'>run_pipeline</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>stg_name</span><span class='hs-layout'>,</span><span class='hs-varid'>stg</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>stgs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-139"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-layout'>(</span><span class='hs-str'>"runStage "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>stg_name</span> <span class='hs-varop'>++</span> <span class='hs-str'>" {"</span><span class='hs-layout'>)</span>
<a name="line-140"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"workitem   = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span> 
<a name="line-141"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>stg</span> <span class='hs-varid'>ct</span> 
<a name="line-142"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-layout'>(</span><span class='hs-str'>"end stage "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>stg_name</span> <span class='hs-varop'>++</span> <span class='hs-str'>" }"</span><span class='hs-layout'>)</span> <span class='hs-varid'>empty</span>
<a name="line-143"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>run_pipeline</span> <span class='hs-varid'>stgs</span> <span class='hs-varid'>res</span> 
<a name="line-144"></a>               <span class='hs-layout'>}</span>
</pre>\end{code}

Example 1:
  Inert:   {c ~ d, F a ~ t, b ~ Int, a ~ ty} (all given)
  Reagent: a ~ [b] (given)

React with (c~d)     ==> IR (ContinueWith (a~[b]))  True    []
React with (F a ~ t) ==> IR (ContinueWith (a~[b]))  False   [F [b] ~ t]
React with (b ~ Int) ==> IR (ContinueWith (a~[Int]) True    []

Example 2:
  Inert:  {c ~w d, F a ~g t, b ~w Int, a ~w ty}
  Reagent: a ~w [b]

React with (c ~w d)   ==> IR (ContinueWith (a~[b]))  True    []
React with (F a ~g t) ==> IR (ContinueWith (a~[b]))  True    []    (can't rewrite given with wanted!)
etc.

Example 3:
  Inert:  {a ~ Int, F Int ~ b} (given)
  Reagent: F a ~ b (wanted)

React with (a ~ Int)   ==> IR (ContinueWith (F Int ~ b)) True []
React with (F Int ~ b) ==> IR Stop True []    -- after substituting we re-canonicalize and get nothing

\begin{code}
<pre><a name="line-1"></a><a name="thePipeline"></a><span class='hs-definition'>thePipeline</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>String</span><span class='hs-layout'>,</span><span class='hs-conid'>SimplifierStage</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a><span class='hs-definition'>thePipeline</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-str'>"canonicalization"</span><span class='hs-layout'>,</span>        <span class='hs-varid'>canonicalizationStage</span><span class='hs-layout'>)</span>
<a name="line-3"></a>              <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"spontaneous solve"</span><span class='hs-layout'>,</span>       <span class='hs-varid'>spontaneousSolveStage</span><span class='hs-layout'>)</span>
<a name="line-4"></a>              <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"interact with inerts"</span><span class='hs-layout'>,</span>    <span class='hs-varid'>interactWithInertsStage</span><span class='hs-layout'>)</span>
<a name="line-5"></a>              <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"top-level reactions"</span><span class='hs-layout'>,</span>     <span class='hs-varid'>topReactionsStage</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
</pre>\end{code}


\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><a name="canonicalizationStage"></a><span class='hs-comment'>-- The canonicalization stage, see TcCanonical for details</span>
<a name="line-3"></a><span class='hs-comment'>----------------------------------------------------------</span>
<a name="line-4"></a><span class='hs-definition'>canonicalizationStage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplifierStage</span>
<a name="line-5"></a><span class='hs-definition'>canonicalizationStage</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TcCanonical</span><span class='hs-varop'>.</span><span class='hs-varid'>canonicalize</span> 
<a name="line-6"></a>
</pre>\end{code}

*********************************************************************************
*                                                                               * 
                       The spontaneous-solve Stage
*                                                                               *
*********************************************************************************

Note [Efficient Orientation] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are two cases where we have to be careful about 
orienting equalities to get better efficiency. 

Case 1: In Rewriting Equalities (function rewriteEqLHS) 

    When rewriting two equalities with the same LHS:
          (a)  (tv ~ xi1) 
          (b)  (tv ~ xi2) 
    We have a choice of producing work (xi1 ~ xi2) (up-to the
    canonicalization invariants) However, to prevent the inert items
    from getting kicked out of the inerts first, we prefer to
    canonicalize (xi1 ~ xi2) if (b) comes from the inert set, or (xi2
    ~ xi1) if (a) comes from the inert set.
    
    This choice is implemented using the WhichComesFromInert flag. 

Case 2: Functional Dependencies 
    Again, we should prefer, if possible, the inert variables on the RHS

Case 3: IP improvement work
    We must always rewrite so that the inert type is on the right. 

\begin{code}
<pre><a name="line-1"></a><a name="spontaneousSolveStage"></a><span class='hs-definition'>spontaneousSolveStage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplifierStage</span> 
<a name="line-2"></a><span class='hs-definition'>spontaneousSolveStage</span> <span class='hs-varid'>workItem</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mSolve</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>trySpontaneousSolve</span> <span class='hs-varid'>workItem</span>
<a name="line-4"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>spont_solve</span> <span class='hs-varid'>mSolve</span> <span class='hs-layout'>}</span> 
<a name="line-5"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>spont_solve</span> <span class='hs-conid'>SPCantSolve</span> 
<a name="line-6"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCTyEqCan</span> <span class='hs-varid'>workItem</span>                    <span class='hs-comment'>-- Unsolved equality</span>
<a name="line-7"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>kickOutRewritableInerts</span> <span class='hs-varid'>workItem</span>  <span class='hs-comment'>-- NB: will add workItem in inerts</span>
<a name="line-8"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span>
<a name="line-9"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-10"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>continueWith</span> <span class='hs-varid'>workItem</span>
<a name="line-11"></a>        <span class='hs-varid'>spont_solve</span> <span class='hs-layout'>(</span><span class='hs-conid'>SPSolved</span> <span class='hs-varid'>workItem'</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- Post: workItem' must be equality</span>
<a name="line-12"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bumpStepCountTcS</span>
<a name="line-13"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_depth</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-14"></a>                 <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Spontaneous"</span><span class='hs-layout'>)</span> 
<a name="line-15"></a>                           <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_flavor</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span>
<a name="line-16"></a>
<a name="line-17"></a>                 <span class='hs-comment'>-- NB: will add the item in the inerts</span>
<a name="line-18"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>kickOutRewritableInerts</span> <span class='hs-varid'>workItem'</span>
<a name="line-19"></a>               <span class='hs-comment'>-- .. and Stop</span>
<a name="line-20"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span>
<a name="line-21"></a>
<a name="line-22"></a><a name="kickOutRewritableInerts"></a><span class='hs-definition'>kickOutRewritableInerts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span> 
<a name="line-23"></a><span class='hs-comment'>-- Pre:  ct is a CTyEqCan </span>
<a name="line-24"></a><span class='hs-comment'>-- Post: The TcS monad is left with the thinner non-rewritable inerts; but which</span>
<a name="line-25"></a><span class='hs-comment'>--       contains the new constraint.</span>
<a name="line-26"></a><span class='hs-comment'>--       The rewritable end up in the worklist</span>
<a name="line-27"></a><span class='hs-definition'>kickOutRewritableInerts</span> <span class='hs-varid'>ct</span>
<a name="line-28"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "kickOutRewritableInerts" #-}</span>
<a name="line-29"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>wl</span><span class='hs-layout'>,</span><span class='hs-varid'>ieqs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-# SCC "kick_out_rewritable" #-}</span>
<a name="line-30"></a>                      <span class='hs-varid'>modifyInertTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>kick_out_rewritable</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-31"></a>
<a name="line-32"></a>       <span class='hs-comment'>-- Step 1: Rewrite as many of the inert_eqs on the spot! </span>
<a name="line-33"></a>       <span class='hs-comment'>-- NB: if it is a solved constraint just use the cached evidence</span>
<a name="line-34"></a>       
<a name="line-35"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ct_coercion</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getCtCoercion</span> <span class='hs-varid'>ct</span> 
<a name="line-36"></a>
<a name="line-37"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_ieqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-# SCC "rewriteInertEqsFromInertEq" #-}</span>
<a name="line-38"></a>                     <span class='hs-varid'>rewriteInertEqsFromInertEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_tyvar</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span><span class='hs-varid'>ct_coercion</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span> <span class='hs-varid'>ieqs</span>
<a name="line-39"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>modifyInertTcS</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>is</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>()</span><span class='hs-layout'>,</span> <span class='hs-varid'>is</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ieqs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-40"></a>
<a name="line-41"></a>       <span class='hs-comment'>-- Step 2: Add the new guy in</span>
<a name="line-42"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>updInertSetTcS</span> <span class='hs-varid'>ct</span>
<a name="line-43"></a>
<a name="line-44"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Kick out"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wl</span><span class='hs-layout'>)</span>
<a name="line-45"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionWorkList</span> <span class='hs-varid'>wl</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-46"></a>
<a name="line-47"></a><a name="rewriteInertEqsFromInertEq"></a><span class='hs-definition'>rewriteInertEqsFromInertEq</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcTyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>CtFlavor</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- A new substitution</span>
<a name="line-48"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>       <span class='hs-comment'>-- All inert equalities</span>
<a name="line-49"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span><span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- The new inert equalities</span>
<a name="line-50"></a><span class='hs-definition'>rewriteInertEqsFromInertEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst_tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>subst_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>subst_fl</span><span class='hs-layout'>)</span> <span class='hs-varid'>ieqs</span>
<a name="line-51"></a><span class='hs-comment'>-- The goal: traverse the inert equalities and rewrite some of them, dropping some others</span>
<a name="line-52"></a><span class='hs-comment'>-- back to the worklist. This is delicate, see Note [Delicate equality kick-out]</span>
<a name="line-53"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mieqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>Traversable</span><span class='hs-varop'>.</span><span class='hs-varid'>mapM</span> <span class='hs-varid'>do_one</span> <span class='hs-varid'>ieqs</span> 
<a name="line-54"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Original inert equalities:"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ieqs</span><span class='hs-layout'>)</span>
<a name="line-55"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>flatten_justs</span> <span class='hs-varid'>elem</span> <span class='hs-varid'>venv</span>
<a name="line-56"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>act</span><span class='hs-layout'>,</span><span class='hs-varid'>aco</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>elem</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-varid'>venv</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_tyvar</span> <span class='hs-varid'>act</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>act</span><span class='hs-layout'>,</span><span class='hs-varid'>aco</span><span class='hs-layout'>)</span>
<a name="line-57"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>venv</span>                                     
<a name="line-58"></a>            <span class='hs-varid'>final_ieqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldVarEnv</span> <span class='hs-varid'>flatten_justs</span> <span class='hs-varid'>emptyVarEnv</span> <span class='hs-varid'>mieqs</span>
<a name="line-59"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Remaining inert equalities:"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>final_ieqs</span><span class='hs-layout'>)</span>
<a name="line-60"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>final_ieqs</span> <span class='hs-layout'>}</span>
<a name="line-61"></a>
<a name="line-62"></a> <span class='hs-keyword'>where</span> <span class='hs-varid'>do_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-layout'>,</span><span class='hs-varid'>inert_co</span><span class='hs-layout'>)</span>
<a name="line-63"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>subst_fl</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>fl</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst_tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span> 
<a name="line-64"></a>                                      <span class='hs-comment'>-- Annoyingly inefficient, but we can't simply check </span>
<a name="line-65"></a>                                      <span class='hs-comment'>-- that isReflCo co because of cached solved ReflCo evidence.</span>
<a name="line-66"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>fl</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>subst_fl</span> <span class='hs-keyword'>then</span> 
<a name="line-67"></a>               <span class='hs-comment'>-- If also the inert can rewrite the subst it's totally safe </span>
<a name="line-68"></a>               <span class='hs-comment'>-- to rewrite on the spot</span>
<a name="line-69"></a>               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct'</span><span class='hs-layout'>,</span><span class='hs-varid'>inert_co'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewrite_on_the_spot</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-layout'>,</span><span class='hs-varid'>inert_co</span><span class='hs-layout'>)</span>
<a name="line-70"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct'</span><span class='hs-layout'>,</span><span class='hs-varid'>inert_co'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-71"></a>           <span class='hs-keyword'>else</span> <span class='hs-comment'>-- We have to throw inert back to worklist for occurs checks </span>
<a name="line-72"></a>              <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEq</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-73"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span>
<a name="line-74"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-comment'>-- Just keep it there</span>
<a name="line-75"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-layout'>,</span><span class='hs-varid'>inert_co</span><span class='hs-layout'>)</span>
<a name="line-76"></a>         <span class='hs-keyword'>where</span> 
<a name="line-77"></a>	   <span class='hs-comment'>-- We have new guy         co : tv ~ something</span>
<a name="line-78"></a>	   <span class='hs-comment'>-- and old inert  {wanted} cv : tv' ~ rhs[tv]</span>
<a name="line-79"></a>	   <span class='hs-comment'>-- We want to rewrite to</span>
<a name="line-80"></a>	   <span class='hs-comment'>--  	      	     {wanted} cv' : tv' ~ rhs[something] </span>
<a name="line-81"></a>           <span class='hs-comment'>--                cv = cv' ; rhs[Sym co]</span>
<a name="line-82"></a>	   <span class='hs-comment'>--                  </span>
<a name="line-83"></a>           <span class='hs-varid'>rewrite_on_the_spot</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-layout'>,</span><span class='hs-sel'>_inert_co</span><span class='hs-layout'>)</span>
<a name="line-84"></a>             <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pSnd</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcCoercionKind</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-85"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>delCachedEvVar</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>fl</span>
<a name="line-86"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>evc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEqVar</span> <span class='hs-varid'>fl</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs'</span>
<a name="line-87"></a>                  <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ev'</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>evc</span>
<a name="line-88"></a>                  <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>evco'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>ev'</span> 
<a name="line-89"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>fl'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isNewEvVar</span> <span class='hs-varid'>evc</span> <span class='hs-keyword'>then</span>
<a name="line-90"></a>                               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fl</span> <span class='hs-keyword'>of</span> 
<a name="line-91"></a>                                      <span class='hs-conid'>Wanted</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> 
<a name="line-92"></a>                                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>evco'</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>fl</span>
<a name="line-93"></a>                                      <span class='hs-conid'>Given</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> 
<a name="line-94"></a>                                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>ev'</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>fl</span>
<a name="line-95"></a>                                      <span class='hs-conid'>Derived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>
<a name="line-96"></a>                                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>fl</span> <span class='hs-layout'>}</span>
<a name="line-97"></a>                           <span class='hs-keyword'>else</span>
<a name="line-98"></a>                               <span class='hs-keyword'>if</span> <span class='hs-varid'>isWanted</span> <span class='hs-varid'>fl</span> <span class='hs-keyword'>then</span> 
<a name="line-99"></a>                                   <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>evco'</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>fl</span>
<a name="line-100"></a>                               <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-varid'>fl</span>
<a name="line-101"></a>                  <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ct'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ct</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev'</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl'</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs'</span> <span class='hs-layout'>}</span>
<a name="line-102"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct'</span><span class='hs-layout'>,</span><span class='hs-varid'>evco'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-103"></a>           <span class='hs-varid'>ev</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_id</span> <span class='hs-varid'>ct</span>
<a name="line-104"></a>           <span class='hs-varid'>fl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-varid'>ct</span>
<a name="line-105"></a>           <span class='hs-varid'>tv</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-varid'>ct</span>
<a name="line-106"></a>           <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-varid'>ct</span>
<a name="line-107"></a>           <span class='hs-varid'>co</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftTcCoSubstWith</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>subst_tv</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>subst_co</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>rhs</span>
<a name="line-108"></a>
<a name="line-109"></a><a name="kick_out_rewritable"></a><span class='hs-definition'>kick_out_rewritable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InertSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>WorkList</span><span class='hs-layout'>,</span><span class='hs-conid'>TyVarEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span><span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>InertSet</span><span class='hs-layout'>)</span>
<a name="line-110"></a><span class='hs-comment'>-- Returns ALL equalities, to be dealt with later</span>
<a name="line-111"></a><span class='hs-definition'>kick_out_rewritable</span> <span class='hs-varid'>ct</span> <span class='hs-layout'>(</span><span class='hs-conid'>IS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_eqs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqmap</span>
<a name="line-112"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>inert_eq_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inscope</span>
<a name="line-113"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>inert_dicts</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dictmap</span>
<a name="line-114"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>inert_ips</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ipmap</span>
<a name="line-115"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>inert_funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funeqmap</span>
<a name="line-116"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>inert_irreds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irreds</span>
<a name="line-117"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>inert_frozen</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>frozen</span>
<a name="line-118"></a>                           <span class='hs-layout'>}</span> <span class='hs-layout'>)</span>
<a name="line-119"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>kicked_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqmap</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>remaining</span><span class='hs-layout'>)</span>
<a name="line-120"></a>  <span class='hs-keyword'>where</span>
<a name="line-121"></a>    <span class='hs-varid'>kicked_out</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WorkList</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wl_eqs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-122"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>wl_funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>feqs_out</span>
<a name="line-123"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>wl_rest</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bagToList</span> <span class='hs-layout'>(</span><span class='hs-varid'>fro_out</span> <span class='hs-varop'>`andCts`</span> <span class='hs-varid'>dicts_out</span> 
<a name="line-124"></a>                                          <span class='hs-varop'>`andCts`</span> <span class='hs-varid'>ips_out</span> <span class='hs-varop'>`andCts`</span> <span class='hs-varid'>irs_out</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-125"></a>  
<a name="line-126"></a>    <span class='hs-varid'>remaining</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-127"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>inert_eq_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inscope</span> <span class='hs-comment'>-- keep the same, safe and cheap</span>
<a name="line-128"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>inert_dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dicts_in</span>
<a name="line-129"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>inert_ips</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ips_in</span>
<a name="line-130"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>inert_funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>feqs_in</span>
<a name="line-131"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>inert_irreds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irs_in</span>
<a name="line-132"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>inert_frozen</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fro_in</span> 
<a name="line-133"></a>                   <span class='hs-layout'>}</span>
<a name="line-134"></a>
<a name="line-135"></a>    <span class='hs-varid'>fl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-varid'>ct</span>
<a name="line-136"></a>    <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-varid'>ct</span>
<a name="line-137"></a>                               
<a name="line-138"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>ips_out</span><span class='hs-layout'>,</span>   <span class='hs-varid'>ips_in</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionCCanMap</span> <span class='hs-varid'>rewritable</span> <span class='hs-varid'>ipmap</span>
<a name="line-139"></a>
<a name="line-140"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>feqs_out</span><span class='hs-layout'>,</span>  <span class='hs-varid'>feqs_in</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionCtTypeMap</span> <span class='hs-varid'>rewritable</span> <span class='hs-varid'>funeqmap</span>
<a name="line-141"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>dicts_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>dicts_in</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionCCanMap</span> <span class='hs-varid'>rewritable</span> <span class='hs-varid'>dictmap</span>
<a name="line-142"></a>
<a name="line-143"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>irs_out</span><span class='hs-layout'>,</span>   <span class='hs-varid'>irs_in</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>rewritable</span> <span class='hs-varid'>irreds</span>
<a name="line-144"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>fro_out</span><span class='hs-layout'>,</span>   <span class='hs-varid'>fro_in</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>rewritable</span> <span class='hs-varid'>frozen</span>
<a name="line-145"></a>
<a name="line-146"></a>    <span class='hs-varid'>rewritable</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>fl</span> <span class='hs-varop'>`canRewrite`</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>  <span class='hs-varop'>&amp;&amp;</span>
<a name="line-147"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Delicate equality kick-out]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

Delicate:
When kicking out rewritable constraints, it would be safe to simply
kick out all rewritable equalities, but instead we only kick out those
that, when rewritten, may result in occur-check errors. We rewrite the
rest on the spot. Example:

          WorkItem =   [S] a ~ b
          Inerts   = { [W] b ~ [a] }
Now at this point the work item cannot be further rewritten by the
inert (due to the weaker inert flavor), so we are examining if we can
instead rewrite the inert from the workitem. But if we rewrite it on
the spot we have to recanonicalize because of the danger of occurs
errors.  On the other hand if the inert flavor was just as powerful or
more powerful than the workitem flavor, the work-item could not have
reached this stage (because it would have already been rewritten by
the inert).

The coclusion is: we kick out the 'dangerous' equalities that may
require recanonicalization (occurs checks) and the rest we rewrite
unconditionally without further checks, on-the-spot with function
rewriteInertEqsFromInertEq.


\begin{code}
<pre><a name="line-1"></a><a name="SPSolveResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>SPSolveResult</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SPCantSolve</span>
<a name="line-2"></a>                   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SPSolved</span> <span class='hs-conid'>WorkItem</span> 
<a name="line-3"></a>
<a name="line-4"></a><span class='hs-comment'>-- SPCantSolve means that we can't do the unification because e.g. the variable is untouchable</span>
<a name="line-5"></a><span class='hs-comment'>-- SPSolved workItem' gives us a new *given* to go on </span>
<a name="line-6"></a>
<a name="line-7"></a><a name="trySpontaneousSolve"></a><span class='hs-comment'>-- @trySpontaneousSolve wi@ solves equalities where one side is a</span>
<a name="line-8"></a><span class='hs-comment'>-- touchable unification variable.</span>
<a name="line-9"></a><span class='hs-comment'>--     	    See Note [Touchables and givens] </span>
<a name="line-10"></a><span class='hs-definition'>trySpontaneousSolve</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SPSolveResult</span>
<a name="line-11"></a><span class='hs-definition'>trySpontaneousSolve</span> <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gw</span>
<a name="line-12"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGivenOrSolved</span> <span class='hs-varid'>gw</span>
<a name="line-14"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span>
<a name="line-15"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>xi</span>
<a name="line-16"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tch1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isTouchableMetaTyVar</span> <span class='hs-varid'>tv1</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tch2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isTouchableMetaTyVar</span> <span class='hs-varid'>tv2</span>
<a name="line-18"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>tch1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tch2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-19"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span>  <span class='hs-conid'>True</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>trySpontaneousEqTwoWay</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>tv2</span>
<a name="line-20"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span>  <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>trySpontaneousEqOneWay</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>xi</span>
<a name="line-21"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>trySpontaneousEqOneWay</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv2</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span>
<a name="line-22"></a>	   <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span> <span class='hs-layout'>}</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-24"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tch1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isTouchableMetaTyVar</span> <span class='hs-varid'>tv1</span>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>tch1</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>trySpontaneousEqOneWay</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>xi</span>
<a name="line-26"></a>                 <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Untouchable LHS, can't spontaneously solve workitem:"</span> <span class='hs-varop'>$</span>
<a name="line-27"></a>                           <span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span> 
<a name="line-28"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span> <span class='hs-layout'>}</span>
<a name="line-29"></a>       <span class='hs-layout'>}</span>
<a name="line-30"></a>
<a name="line-31"></a>  <span class='hs-comment'>-- No need for </span>
<a name="line-32"></a>  <span class='hs-comment'>--      trySpontaneousSolve (CFunEqCan ...) = ...</span>
<a name="line-33"></a>  <span class='hs-comment'>-- See Note [No touchables as FunEq RHS] in TcSMonad</span>
<a name="line-34"></a><span class='hs-definition'>trySpontaneousSolve</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span>
<a name="line-35"></a>
<a name="line-36"></a><a name="trySpontaneousEqOneWay"></a><span class='hs-comment'>----------------</span>
<a name="line-37"></a><span class='hs-definition'>trySpontaneousEqOneWay</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SubGoalDepth</span> 
<a name="line-38"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavor</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SPSolveResult</span>
<a name="line-39"></a><span class='hs-comment'>-- tv is a MetaTyVar, not untouchable</span>
<a name="line-40"></a><span class='hs-definition'>trySpontaneousEqOneWay</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>xi</span>	
<a name="line-41"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSigTyVar</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isTyVarTy</span> <span class='hs-varid'>xi</span> 
<a name="line-42"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>kxi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>xi</span> <span class='hs-comment'>-- NB: 'xi' is fully rewritten according to the inerts </span>
<a name="line-43"></a>                               <span class='hs-comment'>-- so we have its more specific kind in our hands</span>
<a name="line-44"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>is_sub_kind</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>kxi</span> <span class='hs-varop'>`isSubKindTcS`</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span>
<a name="line-45"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>is_sub_kind</span> <span class='hs-keyword'>then</span>
<a name="line-46"></a>             <span class='hs-varid'>solveWithIdentity</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>xi</span>
<a name="line-47"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span>
<a name="line-48"></a>       <span class='hs-layout'>}</span>
<a name="line-49"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-comment'>-- Still can't solve, sig tyvar and non-variable rhs</span>
<a name="line-50"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SPCantSolve</span>
<a name="line-51"></a>
<a name="line-52"></a><a name="trySpontaneousEqTwoWay"></a><span class='hs-comment'>----------------</span>
<a name="line-53"></a><span class='hs-definition'>trySpontaneousEqTwoWay</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SubGoalDepth</span> 
<a name="line-54"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavor</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SPSolveResult</span>
<a name="line-55"></a><span class='hs-comment'>-- Both tyvars are *touchable* MetaTyvars so there is only a chance for kind error here</span>
<a name="line-56"></a>
<a name="line-57"></a><span class='hs-definition'>trySpontaneousEqTwoWay</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>tv2</span>
<a name="line-58"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>k1_sub_k2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>k1</span> <span class='hs-varop'>`isSubKindTcS`</span> <span class='hs-varid'>k2</span>
<a name="line-59"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>k1_sub_k2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>nicer_to_update_tv2</span>
<a name="line-60"></a>         <span class='hs-keyword'>then</span> <span class='hs-varid'>solveWithIdentity</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv2</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span>
<a name="line-61"></a>         <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-62"></a>       <span class='hs-layout'>{</span> <span class='hs-varid'>k2_sub_k1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>k2</span> <span class='hs-varop'>`isSubKindTcS`</span> <span class='hs-varid'>k1</span>
<a name="line-63"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>k2_sub_k1</span> <span class='hs-layout'>)</span>  <span class='hs-comment'>-- they were unified in TcCanonical</span>
<a name="line-64"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solveWithIdentity</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>tv1</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-65"></a>  <span class='hs-keyword'>where</span>
<a name="line-66"></a>    <span class='hs-varid'>k1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv1</span>
<a name="line-67"></a>    <span class='hs-varid'>k2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv2</span>
<a name="line-68"></a>    <span class='hs-varid'>nicer_to_update_tv2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isSigTyVar</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isSystemName</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-varop'>.</span><span class='hs-varid'>varName</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span>
<a name="line-69"></a>
</pre>\end{code}

Note [Kind errors] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider the wanted problem: 
      alpha ~ (# Int, Int #) 
where alpha :: ArgKind and (# Int, Int #) :: (#). We can't spontaneously solve this constraint, 
but we should rather reject the program that give rise to it. If 'trySpontaneousEqTwoWay' 
simply returns @CantSolve@ then that wanted constraint is going to propagate all the way and 
get quantified over in inference mode. That's bad because we do know at this point that the 
constraint is insoluble. Instead, we call 'recKindErrorTcS' here, which will fail later on.

The same applies in canonicalization code in case of kind errors in the givens. 

However, when we canonicalize givens we only check for compatibility (@compatKind@). 
If there were a kind error in the givens, this means some form of inconsistency or dead code.

You may think that when we spontaneously solve wanteds we may have to look through the 
bindings to determine the right kind of the RHS type. E.g one may be worried that xi is 
@alpha@ where alpha :: ? and a previous spontaneous solving has set (alpha := f) with (f :: *).
But we orient our constraints so that spontaneously solved ones can rewrite all other constraint
so this situation can't happen. 

Note [Spontaneous solving and kind compatibility] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Note that our canonical constraints insist that *all* equalities (tv ~
xi) or (F xis ~ rhs) require the LHS and the RHS to have *compatible*
the same kinds.  ("compatible" means one is a subKind of the other.)

  - It can't be *equal* kinds, because
     b) wanted constraints don't necessarily have identical kinds
               eg   alpha::? ~ Int
     b) a solved wanted constraint becomes a given

  - SPJ thinks that *given* constraints (tv ~ tau) always have that
    tau has a sub-kind of tv; and when solving wanted constraints
    in trySpontaneousEqTwoWay we re-orient to achieve this.

  - Note that the kind invariant is maintained by rewriting.
    Eg wanted1 rewrites wanted2; if both were compatible kinds before,
       wanted2 will be afterwards.  Similarly givens.

Caveat:
  - Givens from higher-rank, such as: 
          type family T b :: * -> * -> * 
          type instance T Bool = (->) 

          f :: forall a. ((T a ~ (->)) => ...) -> a -> ... 
          flop = f (...) True 
     Whereas we would be able to apply the type instance, we would not be able to 
     use the given (T Bool ~ (->)) in the body of 'flop' 


Note [Avoid double unifications] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The spontaneous solver has to return a given which mentions the unified unification
variable *on the left* of the equality. Here is what happens if not: 
  Original wanted:  (a ~ alpha),  (alpha ~ Int) 
We spontaneously solve the first wanted, without changing the order! 
      given : a ~ alpha      [having unified alpha := a] 
Now the second wanted comes along, but he cannot rewrite the given, so we simply continue.
At the end we spontaneously solve that guy, *reunifying*  [alpha := Int] 

We avoid this problem by orienting the resulting given so that the unification
variable is on the left.  [Note that alternatively we could attempt to
enforce this at canonicalization]

See also Note [No touchables as FunEq RHS] in TcSMonad; avoiding
double unifications is the main reason we disallow touchable
unification variables as RHS of type family equations: F xis ~ alpha.

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>----------------</span>
<a name="line-2"></a>
<a name="line-3"></a><a name="solveWithIdentity"></a><span class='hs-definition'>solveWithIdentity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SubGoalDepth</span> 
<a name="line-4"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavor</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>SPSolveResult</span>
<a name="line-5"></a><span class='hs-comment'>-- Solve with the identity coercion </span>
<a name="line-6"></a><span class='hs-comment'>-- Precondition: kind(xi) is a sub-kind of kind(tv)</span>
<a name="line-7"></a><span class='hs-comment'>-- Precondition: CtFlavor is Wanted or Derived</span>
<a name="line-8"></a><span class='hs-comment'>-- See [New Wanted Superclass Work] to see why solveWithIdentity </span>
<a name="line-9"></a><span class='hs-comment'>--     must work for Derived as well as Wanted</span>
<a name="line-10"></a><span class='hs-comment'>-- Returns: workItem where </span>
<a name="line-11"></a><span class='hs-comment'>--        workItem = the new Given constraint</span>
<a name="line-12"></a><span class='hs-definition'>solveWithIdentity</span> <span class='hs-varid'>d</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>wd</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>xi</span> 
<a name="line-13"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Sneaky unification:"</span> <span class='hs-varop'>$</span> 
<a name="line-14"></a>                       <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"Coercion variable:  "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>eqv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wd</span><span class='hs-layout'>,</span> 
<a name="line-15"></a>                             <span class='hs-varid'>text</span> <span class='hs-str'>"Coercion:           "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span>
<a name="line-16"></a>                             <span class='hs-varid'>text</span> <span class='hs-str'>"Left  Kind is     : "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-17"></a>                             <span class='hs-varid'>text</span> <span class='hs-str'>"Right Kind is     : "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-varid'>xi</span><span class='hs-layout'>)</span>
<a name="line-18"></a>                            <span class='hs-keyglyph'>]</span>
<a name="line-19"></a>
<a name="line-20"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>xi</span>
<a name="line-21"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>refl_xi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>xi</span>
<a name="line-22"></a>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>solved_fl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSolvedFlavor</span> <span class='hs-varid'>wd</span> <span class='hs-conid'>UnkSkol</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-varid'>refl_xi</span><span class='hs-layout'>)</span> 
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>eqv_given</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newGivenEqVar</span> <span class='hs-varid'>solved_fl</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>refl_xi</span>
<a name="line-25"></a>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>wd</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>refl_xi</span> <span class='hs-varid'>wd</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-27"></a>           <span class='hs-comment'>-- We don't want to do this for Derived, that's why we use 'when (isWanted wd)'</span>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>SPSolved</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv_given</span>
<a name="line-29"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solved_fl</span>
<a name="line-30"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}


*********************************************************************************
*                                                                               * 
                       The interact-with-inert Stage
*                                                                               *
*********************************************************************************

Note [The Solver Invariant]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
We always add Givens first.  So you might think that the solver has
the invariant

   If the work-item is Given, 
   then the inert item must Given

But this isn't quite true.  Suppose we have, 
    c1: [W] beta ~ [alpha], c2 : [W] blah, c3 :[W] alpha ~ Int
After processing the first two, we get
     c1: [G] beta ~ [alpha], c2 : [W] blah
Now, c3 does not interact with the the given c1, so when we spontaneously
solve c3, we must re-react it with the inert set.  So we can attempt a 
reaction between inert c2 [W] and work-item c3 [G].

It *is* true that [Solver Invariant]
   If the work-item is Given, 
   AND there is a reaction
   then the inert item must Given
or, equivalently,
   If the work-item is Given, 
   and the inert item is Wanted/Derived
   then there is no reaction

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>-- Interaction result of  WorkItem &lt;~&gt; AtomicInert</span>
<a name="line-2"></a>
<a name="line-3"></a><a name="InteractResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>InteractResult</span> 
<a name="line-4"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IRWorkItemConsumed</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ir_fire</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-layout'>}</span> 
<a name="line-5"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IRInertConsumed</span>    <span class='hs-layout'>{</span> <span class='hs-varid'>ir_fire</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-layout'>}</span> 
<a name="line-6"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IRKeepGoing</span>        <span class='hs-layout'>{</span> <span class='hs-varid'>ir_fire</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-layout'>}</span>
<a name="line-7"></a>
<a name="line-8"></a><a name="irWorkItemConsumed"></a><span class='hs-definition'>irWorkItemConsumed</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>InteractResult</span>
<a name="line-9"></a><span class='hs-definition'>irWorkItemConsumed</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>IRWorkItemConsumed</span> <span class='hs-varid'>str</span><span class='hs-layout'>)</span> 
<a name="line-10"></a>
<a name="line-11"></a><a name="irInertConsumed"></a><span class='hs-definition'>irInertConsumed</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>InteractResult</span>
<a name="line-12"></a><span class='hs-definition'>irInertConsumed</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>IRInertConsumed</span> <span class='hs-varid'>str</span><span class='hs-layout'>)</span> 
<a name="line-13"></a>
<a name="line-14"></a><a name="irKeepGoing"></a><span class='hs-definition'>irKeepGoing</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>InteractResult</span> 
<a name="line-15"></a><span class='hs-definition'>irKeepGoing</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>IRKeepGoing</span> <span class='hs-varid'>str</span><span class='hs-layout'>)</span> 
<a name="line-16"></a><span class='hs-comment'>-- You can't discard neither workitem or inert, but you must keep </span>
<a name="line-17"></a><span class='hs-comment'>-- going. It's possible that new work is waiting in the TcS worklist. </span>
<a name="line-18"></a>
<a name="line-19"></a>
<a name="line-20"></a><a name="interactWithInertsStage"></a><span class='hs-definition'>interactWithInertsStage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span> 
<a name="line-21"></a><span class='hs-comment'>-- Precondition: if the workitem is a CTyEqCan then it will not be able to </span>
<a name="line-22"></a><span class='hs-comment'>-- react with anything at this stage. </span>
<a name="line-23"></a><span class='hs-definition'>interactWithInertsStage</span> <span class='hs-varid'>wi</span> 
<a name="line-24"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSContext</span>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>simplEqsOnly</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>then</span> 
<a name="line-26"></a>             <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span>
<a name="line-27"></a>         <span class='hs-keyword'>else</span> 
<a name="line-28"></a>             <span class='hs-varid'>extractRelevantInerts</span> <span class='hs-varid'>wi</span> <span class='hs-varop'>&gt;&gt;=</span> 
<a name="line-29"></a>               <span class='hs-varid'>foldlBagM</span> <span class='hs-varid'>interact_next</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-30"></a>
<a name="line-31"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>interact_next</span> <span class='hs-conid'>Stop</span> <span class='hs-varid'>atomic_inert</span> 
<a name="line-32"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updInertSetTcS</span> <span class='hs-varid'>atomic_inert</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span>
<a name="line-33"></a>        <span class='hs-varid'>interact_next</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span> <span class='hs-varid'>atomic_inert</span> 
<a name="line-34"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ir</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>doInteractWithInert</span> <span class='hs-varid'>atomic_inert</span> <span class='hs-varid'>wi</span>
<a name="line-35"></a>               <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>mk_msg</span> <span class='hs-varid'>rule</span> <span class='hs-varid'>keep_doc</span> 
<a name="line-36"></a>                       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-varid'>rule</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>keep_doc</span>
<a name="line-37"></a>      	                 <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Inert ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>atomic_inert</span>
<a name="line-38"></a>      	                          <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Work ="</span><span class='hs-layout'>)</span>  <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wi</span> <span class='hs-keyglyph'>]</span>
<a name="line-39"></a>               <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ir</span> <span class='hs-keyword'>of</span> 
<a name="line-40"></a>                   <span class='hs-conid'>IRWorkItemConsumed</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ir_fire</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule</span> <span class='hs-layout'>}</span> 
<a name="line-41"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bumpStepCountTcS</span>
<a name="line-42"></a>                             <span class='hs-layout'>;</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_depth</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span> 
<a name="line-43"></a>                                            <span class='hs-layout'>(</span><span class='hs-varid'>mk_msg</span> <span class='hs-varid'>rule</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"WorkItemConsumed"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-44"></a>                             <span class='hs-layout'>;</span> <span class='hs-varid'>updInertSetTcS</span> <span class='hs-varid'>atomic_inert</span>
<a name="line-45"></a>                             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span> 
<a name="line-46"></a>                   <span class='hs-conid'>IRInertConsumed</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ir_fire</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule</span> <span class='hs-layout'>}</span>
<a name="line-47"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bumpStepCountTcS</span>
<a name="line-48"></a>                             <span class='hs-layout'>;</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_depth</span> <span class='hs-varid'>atomic_inert</span><span class='hs-layout'>)</span> 
<a name="line-49"></a>                                            <span class='hs-layout'>(</span><span class='hs-varid'>mk_msg</span> <span class='hs-varid'>rule</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"InertItemConsumed"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-50"></a>                             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-51"></a>                   <span class='hs-conid'>IRKeepGoing</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-comment'>-- Should we do a bumpStepCountTcS? No for now.</span>
<a name="line-52"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>updInertSetTcS</span> <span class='hs-varid'>atomic_inert</span>
<a name="line-53"></a>                             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-54"></a>               <span class='hs-layout'>}</span>
<a name="line-55"></a>   
<a name="line-56"></a><a name="WhichComesFromInert"></a><span class='hs-comment'>--------------------------------------------</span>
<a name="line-57"></a><a name="WhichComesFromInert"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>WhichComesFromInert</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LeftComesFromInert</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RightComesFromInert</span>
<a name="line-58"></a>
<a name="line-59"></a><a name="doInteractWithInert"></a><span class='hs-definition'>doInteractWithInert</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>InteractResult</span>
<a name="line-60"></a><span class='hs-comment'>-- Identical class constraints.</span>
<a name="line-61"></a><span class='hs-definition'>doInteractWithInert</span>
<a name="line-62"></a>  <span class='hs-varid'>inertItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys1</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> 
<a name="line-63"></a>   <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-sel'>_d2</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl2</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls2</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-64"></a>
<a name="line-65"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>cls1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>cls2</span>  
<a name="line-66"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pty1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls1</span> <span class='hs-varid'>tys1</span>
<a name="line-67"></a>             <span class='hs-varid'>pty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls2</span> <span class='hs-varid'>tys2</span>
<a name="line-68"></a>             <span class='hs-varid'>inert_pred_loc</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>pty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprFlavorArising</span> <span class='hs-varid'>fl1</span><span class='hs-layout'>)</span>
<a name="line-69"></a>             <span class='hs-varid'>work_item_pred_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>pty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprFlavorArising</span> <span class='hs-varid'>fl2</span><span class='hs-layout'>)</span>
<a name="line-70"></a>
<a name="line-71"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"doInteractWithInert"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"inertItem = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inertItem</span>
<a name="line-72"></a>                                              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"workItem  = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-73"></a>
<a name="line-74"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>any_fundeps</span> 
<a name="line-75"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isGivenOrSolved</span> <span class='hs-varid'>fl1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isGivenOrSolved</span> <span class='hs-varid'>fl2</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-76"></a>              <span class='hs-comment'>-- NB: We don't create fds for given (and even solved), have not seen a useful</span>
<a name="line-77"></a>              <span class='hs-comment'>-- situation for these and even if we did we'd have to be very careful to only</span>
<a name="line-78"></a>              <span class='hs-comment'>-- create Derived's and not Wanteds. </span>
<a name="line-79"></a>
<a name="line-80"></a>              <span class='hs-keyword'>else</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>improveFromAnother</span> <span class='hs-varid'>inert_pred_loc</span> <span class='hs-varid'>work_item_pred_loc</span>
<a name="line-81"></a>                       <span class='hs-varid'>wloc</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>get_workitem_wloc</span> <span class='hs-varid'>fl2</span> 
<a name="line-82"></a>                   <span class='hs-keyword'>in</span> <span class='hs-varid'>rewriteWithFunDeps</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-varid'>tys2</span> <span class='hs-varid'>wloc</span>
<a name="line-83"></a>                      <span class='hs-comment'>-- See Note [Efficient Orientation], [When improvement happens]</span>
<a name="line-84"></a>
<a name="line-85"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>any_fundeps</span> <span class='hs-keyword'>of</span>
<a name="line-86"></a>           <span class='hs-comment'>-- No Functional Dependencies </span>
<a name="line-87"></a>           <span class='hs-conid'>Nothing</span>             
<a name="line-88"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>eqTypes</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>solveOneFromTheOther</span> <span class='hs-str'>"Cls/Cls"</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvId</span> <span class='hs-varid'>d1</span><span class='hs-layout'>,</span><span class='hs-varid'>fl1</span><span class='hs-layout'>)</span> <span class='hs-varid'>workItem</span>
<a name="line-89"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>irKeepGoing</span> <span class='hs-str'>"NOP"</span>
<a name="line-90"></a>
<a name="line-91"></a>           <span class='hs-comment'>-- Actual Functional Dependencies</span>
<a name="line-92"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-sel'>_rewritten_tys2</span><span class='hs-layout'>,</span><span class='hs-sel'>_cos2</span><span class='hs-layout'>,</span><span class='hs-varid'>fd_work</span><span class='hs-layout'>)</span>
<a name="line-93"></a>              <span class='hs-comment'>-- Standard thing: create derived fds and keep on going. Importantly we don't</span>
<a name="line-94"></a>               <span class='hs-comment'>-- throw workitem back in the worklist because this can cause loops. See #5236.</span>
<a name="line-95"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>emitFDWorkAsDerived</span> <span class='hs-varid'>fd_work</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_depth</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-96"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>irKeepGoing</span> <span class='hs-str'>"Cls/Cls (new fundeps)"</span> <span class='hs-layout'>}</span> <span class='hs-comment'>-- Just keep going without droping the inert </span>
<a name="line-97"></a>       <span class='hs-layout'>}</span>
<a name="line-98"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>get_workitem_wloc</span> <span class='hs-layout'>(</span><span class='hs-conid'>Wanted</span> <span class='hs-varid'>wl</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wl</span> 
<a name="line-99"></a>        <span class='hs-varid'>get_workitem_wloc</span> <span class='hs-layout'>(</span><span class='hs-conid'>Derived</span> <span class='hs-varid'>wl</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wl</span> 
<a name="line-100"></a>        <span class='hs-varid'>get_workitem_wloc</span> <span class='hs-layout'>(</span><span class='hs-conid'>Given</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"Unexpected given!"</span>
<a name="line-101"></a>
<a name="line-102"></a>
<a name="line-103"></a><span class='hs-comment'>-- Two pieces of irreducible evidence: if their types are *exactly identical* we can</span>
<a name="line-104"></a><span class='hs-comment'>-- rewrite them. We can never improve using this: if we want ty1 :: Constraint and have</span>
<a name="line-105"></a><span class='hs-comment'>-- ty2 :: Constraint it clearly does not mean that (ty1 ~ ty2)</span>
<a name="line-106"></a><span class='hs-definition'>doInteractWithInert</span> <span class='hs-layout'>(</span><span class='hs-conid'>CIrredEvCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ifl</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty1</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-107"></a>           <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CIrredEvCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-108"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>ty2</span>
<a name="line-109"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solveOneFromTheOther</span> <span class='hs-str'>"Irred/Irred"</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvId</span> <span class='hs-varid'>id1</span><span class='hs-layout'>,</span><span class='hs-varid'>ifl</span><span class='hs-layout'>)</span> <span class='hs-varid'>workItem</span>
<a name="line-110"></a>
<a name="line-111"></a><span class='hs-comment'>-- Two implicit parameter constraints.  If the names are the same,</span>
<a name="line-112"></a><span class='hs-comment'>-- but their types are not, we generate a wanted type equality </span>
<a name="line-113"></a><span class='hs-comment'>-- that equates the type (this is "improvement").  </span>
<a name="line-114"></a><span class='hs-comment'>-- However, we don't actually need the coercion evidence,</span>
<a name="line-115"></a><span class='hs-comment'>-- so we just generate a fresh coercion variable that isn't used anywhere.</span>
<a name="line-116"></a><span class='hs-definition'>doInteractWithInert</span> <span class='hs-layout'>(</span><span class='hs-conid'>CIPCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ifl</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ip_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nm1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ip_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty1</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> 
<a name="line-117"></a>           <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CIPCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wfl</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ip_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nm2</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ip_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-118"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>nm1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>nm2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isGivenOrSolved</span> <span class='hs-varid'>wfl</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isGivenOrSolved</span> <span class='hs-varid'>ifl</span>
<a name="line-119"></a>  <span class='hs-keyglyph'>=</span> 	<span class='hs-comment'>-- See Note [Overriding implicit parameters]</span>
<a name="line-120"></a>        <span class='hs-comment'>-- Dump the inert item, override totally with the new one</span>
<a name="line-121"></a>	<span class='hs-comment'>-- Do not require type equality</span>
<a name="line-122"></a>	<span class='hs-comment'>-- For example, given let ?x::Int = 3 in let ?x::Bool = True in ...</span>
<a name="line-123"></a>	<span class='hs-comment'>--              we must *override* the outer one with the inner one</span>
<a name="line-124"></a>    <span class='hs-varid'>irInertConsumed</span> <span class='hs-str'>"IP/IP (override inert)"</span>
<a name="line-125"></a>
<a name="line-126"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>nm1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>nm2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>ty2</span> 
<a name="line-127"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solveOneFromTheOther</span> <span class='hs-str'>"IP/IP"</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvId</span> <span class='hs-varid'>id1</span><span class='hs-layout'>,</span><span class='hs-varid'>ifl</span><span class='hs-layout'>)</span> <span class='hs-varid'>workItem</span> 
<a name="line-128"></a>
<a name="line-129"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>nm1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>nm2</span>
<a name="line-130"></a>  <span class='hs-keyglyph'>=</span>  	<span class='hs-comment'>-- See Note [When improvement happens]</span>
<a name="line-131"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>flav</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Wanted</span> <span class='hs-layout'>(</span><span class='hs-varid'>combineCtLoc</span> <span class='hs-varid'>ifl</span> <span class='hs-varid'>wfl</span><span class='hs-layout'>)</span>
<a name="line-132"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>eqv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEqVar</span> <span class='hs-varid'>flav</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ty1</span> <span class='hs-comment'>-- See Note [Efficient Orientation]</span>
<a name="line-133"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNewEvVar</span> <span class='hs-varid'>eqv</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-134"></a>              <span class='hs-layout'>(</span><span class='hs-keyword'>let</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>eqv</span> 
<a name="line-135"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flav</span>
<a name="line-136"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_depth</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>}</span>
<a name="line-137"></a>              <span class='hs-keyword'>in</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEq</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-138"></a>
<a name="line-139"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>wfl</span> <span class='hs-keyword'>of</span>
<a name="line-140"></a>           <span class='hs-conid'>Given</span>   <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"Unexpected given IP"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-141"></a>           <span class='hs-conid'>Derived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"Unexpected derived IP"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-142"></a>           <span class='hs-conid'>Wanted</span>  <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-143"></a>               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_id</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span> 
<a name="line-144"></a>                            <span class='hs-layout'>(</span><span class='hs-varid'>mkEvCast</span> <span class='hs-varid'>id1</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>ipTyCon</span> <span class='hs-varid'>nm1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>eqv</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>wfl</span>
<a name="line-145"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>irWorkItemConsumed</span> <span class='hs-str'>"IP/IP (solved by rewriting)"</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-146"></a>
<a name="line-147"></a><span class='hs-definition'>doInteractWithInert</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc1</span>
<a name="line-148"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d1</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> 
<a name="line-149"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv2</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl2</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc2</span>
<a name="line-150"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args2</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-151"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>lhss_match</span>  
<a name="line-152"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>GivenSolved</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isGiven_maybe</span> <span class='hs-varid'>fl1</span> <span class='hs-comment'>-- Inert is solved and we can simply ignore it</span>
<a name="line-153"></a>                                          <span class='hs-comment'>-- when workitem is given/solved</span>
<a name="line-154"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isGivenOrSolved</span> <span class='hs-varid'>fl2</span>
<a name="line-155"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irInertConsumed</span> <span class='hs-str'>"FunEq/FunEq"</span>
<a name="line-156"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>lhss_match</span> 
<a name="line-157"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>GivenSolved</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isGiven_maybe</span> <span class='hs-varid'>fl2</span> <span class='hs-comment'>-- Workitem is solved and we can ignore it when</span>
<a name="line-158"></a>                                               <span class='hs-comment'>-- the inert is given/solved</span>
<a name="line-159"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isGivenOrSolved</span> <span class='hs-varid'>fl1</span>                 
<a name="line-160"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irWorkItemConsumed</span> <span class='hs-str'>"FunEq/FunEq"</span> 
<a name="line-161"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>fl1</span> <span class='hs-varop'>`canSolve`</span> <span class='hs-varid'>fl2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>lhss_match</span>
<a name="line-162"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rewriteEqLHS</span> <span class='hs-conid'>LeftComesFromInert</span>  <span class='hs-layout'>(</span><span class='hs-varid'>eqv1</span><span class='hs-layout'>,</span><span class='hs-varid'>xi1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqv2</span><span class='hs-layout'>,</span><span class='hs-varid'>d2</span><span class='hs-layout'>,</span><span class='hs-varid'>fl2</span><span class='hs-layout'>,</span><span class='hs-varid'>xi2</span><span class='hs-layout'>)</span> 
<a name="line-163"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>irWorkItemConsumed</span> <span class='hs-str'>"FunEq/FunEq"</span> <span class='hs-layout'>}</span>
<a name="line-164"></a>
<a name="line-165"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>fl2</span> <span class='hs-varop'>`canSolve`</span> <span class='hs-varid'>fl1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>lhss_match</span>
<a name="line-166"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rewriteEqLHS</span> <span class='hs-conid'>RightComesFromInert</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqv2</span><span class='hs-layout'>,</span><span class='hs-varid'>xi2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqv1</span><span class='hs-layout'>,</span><span class='hs-varid'>d1</span><span class='hs-layout'>,</span><span class='hs-varid'>fl1</span><span class='hs-layout'>,</span><span class='hs-varid'>xi1</span><span class='hs-layout'>)</span> 
<a name="line-167"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>irInertConsumed</span> <span class='hs-str'>"FunEq/FunEq"</span><span class='hs-layout'>}</span>
<a name="line-168"></a>  <span class='hs-keyword'>where</span>
<a name="line-169"></a>    <span class='hs-varid'>lhss_match</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tc2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>eqTypes</span> <span class='hs-varid'>args1</span> <span class='hs-varid'>args2</span> 
<a name="line-170"></a>
<a name="line-171"></a>
<a name="line-172"></a><span class='hs-definition'>doInteractWithInert</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irKeepGoing</span> <span class='hs-str'>"NOP"</span>
<a name="line-173"></a>
<a name="line-174"></a>
<a name="line-175"></a><a name="rewriteEqLHS"></a><span class='hs-definition'>rewriteEqLHS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WhichComesFromInert</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>EqVar</span><span class='hs-layout'>,</span><span class='hs-conid'>Xi</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>EqVar</span><span class='hs-layout'>,</span><span class='hs-conid'>SubGoalDepth</span><span class='hs-layout'>,</span><span class='hs-conid'>CtFlavor</span><span class='hs-layout'>,</span><span class='hs-conid'>Xi</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-176"></a><span class='hs-comment'>-- Used to ineract two equalities of the following form: </span>
<a name="line-177"></a><span class='hs-comment'>-- First Equality:   co1: (XXX ~ xi1)  </span>
<a name="line-178"></a><span class='hs-comment'>-- Second Equality:  cv2: (XXX ~ xi2) </span>
<a name="line-179"></a><span class='hs-comment'>-- Where the cv1 `canRewrite` cv2 equality </span>
<a name="line-180"></a><span class='hs-comment'>-- We have an option of creating new work (xi1 ~ xi2) OR (xi2 ~ xi1), </span>
<a name="line-181"></a><span class='hs-comment'>--    See Note [Efficient Orientation] for that </span>
<a name="line-182"></a><span class='hs-definition'>rewriteEqLHS</span> <span class='hs-conid'>LeftComesFromInert</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqv1</span><span class='hs-layout'>,</span><span class='hs-varid'>xi1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqv2</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>,</span><span class='hs-varid'>gw</span><span class='hs-layout'>,</span><span class='hs-varid'>xi2</span><span class='hs-layout'>)</span> 
<a name="line-183"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>delCachedEvVar</span> <span class='hs-varid'>eqv2</span> <span class='hs-varid'>gw</span> <span class='hs-comment'>-- Similarly to canonicalization!</span>
<a name="line-184"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>evc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEqVar</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>xi1</span>
<a name="line-185"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>eqv2'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>evc</span>
<a name="line-186"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>gw'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>gw</span> <span class='hs-keyword'>of</span> 
<a name="line-187"></a>           <span class='hs-conid'>Wanted</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> 
<a name="line-188"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>eqv2</span> 
<a name="line-189"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv1</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv2'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>gw</span>
<a name="line-190"></a>           <span class='hs-conid'>Given</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>
<a name="line-191"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>eqv2'</span>
<a name="line-192"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv2</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv1</span><span class='hs-layout'>)</span> <span class='hs-varid'>gw</span>
<a name="line-193"></a>           <span class='hs-conid'>Derived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> 
<a name="line-194"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>gw</span>
<a name="line-195"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNewEvVar</span> <span class='hs-varid'>evc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> 
<a name="line-196"></a>              <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv2'</span>
<a name="line-197"></a>                                                              <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gw'</span>
<a name="line-198"></a>                                                              <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-199"></a>
<a name="line-200"></a><span class='hs-definition'>rewriteEqLHS</span> <span class='hs-conid'>RightComesFromInert</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqv1</span><span class='hs-layout'>,</span><span class='hs-varid'>xi1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqv2</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>,</span><span class='hs-varid'>gw</span><span class='hs-layout'>,</span><span class='hs-varid'>xi2</span><span class='hs-layout'>)</span> 
<a name="line-201"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>delCachedEvVar</span> <span class='hs-varid'>eqv2</span> <span class='hs-varid'>gw</span> <span class='hs-comment'>-- Similarly to canonicalization!</span>
<a name="line-202"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>evc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEqVar</span> <span class='hs-varid'>gw</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span>
<a name="line-203"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>eqv2'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>evc</span>
<a name="line-204"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>gw'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>gw</span> <span class='hs-keyword'>of</span>
<a name="line-205"></a>           <span class='hs-conid'>Wanted</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> 
<a name="line-206"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>eqv2</span>
<a name="line-207"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv1</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv2'</span><span class='hs-layout'>)</span> <span class='hs-varid'>gw</span>
<a name="line-208"></a>           <span class='hs-conid'>Given</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>  
<a name="line-209"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>eqv2'</span>
<a name="line-210"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv1</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv2</span><span class='hs-layout'>)</span> <span class='hs-varid'>gw</span>
<a name="line-211"></a>           <span class='hs-conid'>Derived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> 
<a name="line-212"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>gw</span>
<a name="line-213"></a>
<a name="line-214"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNewEvVar</span> <span class='hs-varid'>evc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-215"></a>              <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv2'</span>
<a name="line-216"></a>                                                              <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gw'</span>
<a name="line-217"></a>                                                              <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-218"></a>
<a name="line-219"></a><a name="solveOneFromTheOther"></a><span class='hs-definition'>solveOneFromTheOther</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span>             <span class='hs-comment'>-- Info </span>
<a name="line-220"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvTerm</span><span class='hs-layout'>,</span> <span class='hs-conid'>CtFlavor</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Inert </span>
<a name="line-221"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span>        <span class='hs-comment'>-- WorkItem </span>
<a name="line-222"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>InteractResult</span>
<a name="line-223"></a><span class='hs-comment'>-- Preconditions: </span>
<a name="line-224"></a><span class='hs-comment'>-- 1) inert and work item represent evidence for the /same/ predicate</span>
<a name="line-225"></a><span class='hs-comment'>-- 2) ip/class/irred evidence (no coercions) only</span>
<a name="line-226"></a><span class='hs-definition'>solveOneFromTheOther</span> <span class='hs-varid'>info</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev_term</span><span class='hs-layout'>,</span><span class='hs-varid'>ifl</span><span class='hs-layout'>)</span> <span class='hs-varid'>workItem</span>
<a name="line-227"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDerived</span> <span class='hs-varid'>wfl</span>
<a name="line-228"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irWorkItemConsumed</span> <span class='hs-layout'>(</span><span class='hs-str'>"Solved[DW] "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>info</span><span class='hs-layout'>)</span>
<a name="line-229"></a>
<a name="line-230"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDerived</span> <span class='hs-varid'>ifl</span> <span class='hs-comment'>-- The inert item is Derived, we can just throw it away, </span>
<a name="line-231"></a>    	      	  <span class='hs-comment'>-- The workItem is inert wrt earlier inert-set items, </span>
<a name="line-232"></a>		  <span class='hs-comment'>-- so it's safe to continue on from this point</span>
<a name="line-233"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irInertConsumed</span> <span class='hs-layout'>(</span><span class='hs-str'>"Solved[DI] "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>info</span><span class='hs-layout'>)</span>
<a name="line-234"></a>  
<a name="line-235"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>GivenSolved</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isGiven_maybe</span> <span class='hs-varid'>ifl</span><span class='hs-layout'>,</span> <span class='hs-varid'>isGivenOrSolved</span> <span class='hs-varid'>wfl</span>
<a name="line-236"></a>    <span class='hs-comment'>-- Same if the inert is a GivenSolved -- just get rid of it</span>
<a name="line-237"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>irInertConsumed</span> <span class='hs-layout'>(</span><span class='hs-str'>"Solved[SI] "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>info</span><span class='hs-layout'>)</span>
<a name="line-238"></a>
<a name="line-239"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-240"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>ifl</span> <span class='hs-varop'>`canSolve`</span> <span class='hs-varid'>wfl</span> <span class='hs-layout'>)</span>
<a name="line-241"></a>      <span class='hs-comment'>-- Because of Note [The Solver Invariant], plus Derived dealt with</span>
<a name="line-242"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>wfl</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEvBind</span> <span class='hs-varid'>wid</span> <span class='hs-varid'>ev_term</span> <span class='hs-varid'>wfl</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-243"></a>           <span class='hs-comment'>-- Overwrite the binding, if one exists</span>
<a name="line-244"></a>	   <span class='hs-comment'>-- If both are Given, we already have evidence; no need to duplicate</span>
<a name="line-245"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>irWorkItemConsumed</span> <span class='hs-layout'>(</span><span class='hs-str'>"Solved "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>info</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-246"></a>  <span class='hs-keyword'>where</span> 
<a name="line-247"></a>     <span class='hs-varid'>wfl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-varid'>workItem</span>
<a name="line-248"></a>     <span class='hs-varid'>wid</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_id</span> <span class='hs-varid'>workItem</span>
<a name="line-249"></a>
</pre>\end{code}

Note [Superclasses and recursive dictionaries]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Overlaps with Note [SUPERCLASS-LOOP 1]
                  Note [SUPERCLASS-LOOP 2]
                  Note [Recursive instances and superclases]
    ToDo: check overlap and delete redundant stuff

Right before adding a given into the inert set, we must
produce some more work, that will bring the superclasses 
of the given into scope. The superclass constraints go into 
our worklist. 

When we simplify a wanted constraint, if we first see a matching
instance, we may produce new wanted work. To (1) avoid doing this work 
twice in the future and (2) to handle recursive dictionaries we may ``cache'' 
this item as given into our inert set WITHOUT adding its superclass constraints, 
otherwise we'd be in danger of creating a loop [In fact this was the exact reason
for doing the isGoodRecEv check in an older version of the type checker]. 

But now we have added partially solved constraints to the worklist which may 
interact with other wanteds. Consider the example: 

Example 1: 

    class Eq b => Foo a b        --- 0-th selector
    instance Eq a => Foo [a] a   --- fooDFun

and wanted (Foo [t] t). We are first going to see that the instance matches 
and create an inert set that includes the solved (Foo [t] t) but not its superclasses:
       d1 :_g Foo [t] t                 d1 := EvDFunApp fooDFun d3 
Our work list is going to contain a new *wanted* goal
       d3 :_w Eq t 

Ok, so how do we get recursive dictionaries, at all: 

Example 2:

    data D r = ZeroD | SuccD (r (D r));
    
    instance (Eq (r (D r))) => Eq (D r) where
        ZeroD     == ZeroD     = True
        (SuccD a) == (SuccD b) = a == b
        _         == _         = False;
    
    equalDC :: D [] -> D [] -> Bool;
    equalDC = (==);

We need to prove (Eq (D [])). Here's how we go:

	d1 :_w Eq (D [])

by instance decl, holds if
	d2 :_w Eq [D []]
	where 	d1 = dfEqD d2

*BUT* we have an inert set which gives us (no superclasses): 
        d1 :_g Eq (D []) 
By the instance declaration of Eq we can show the 'd2' goal if 
	d3 :_w Eq (D [])
	where	d2 = dfEqList d3
		d1 = dfEqD d2
Now, however this wanted can interact with our inert d1 to set: 
        d3 := d1 
and solve the goal. Why was this interaction OK? Because, if we chase the 
evidence of d1 ~~> dfEqD d2 ~~-> dfEqList d3, so by setting d3 := d1 we 
are really setting
        d3 := dfEqD2 (dfEqList d3) 
which is FINE because the use of d3 is protected by the instance function 
applications. 

So, our strategy is to try to put solved wanted dictionaries into the
inert set along with their superclasses (when this is meaningful,
i.e. when new wanted goals are generated) but solve a wanted dictionary
from a given only in the case where the evidence variable of the
wanted is mentioned in the evidence of the given (recursively through
the evidence binds) in a protected way: more instance function applications 
than superclass selectors.

Here are some more examples from GHC's previous type checker


Example 3: 
This code arises in the context of "Scrap Your Boilerplate with Class"

    class Sat a
    class Data ctx a
    instance  Sat (ctx Char)             => Data ctx Char       -- dfunData1
    instance (Sat (ctx [a]), Data ctx a) => Data ctx [a]        -- dfunData2

    class Data Maybe a => Foo a    

    instance Foo t => Sat (Maybe t)                             -- dfunSat

    instance Data Maybe a => Foo a                              -- dfunFoo1
    instance Foo a        => Foo [a]                            -- dfunFoo2
    instance                 Foo [Char]                         -- dfunFoo3

Consider generating the superclasses of the instance declaration
	 instance Foo a => Foo [a]

So our problem is this
    d0 :_g Foo t
    d1 :_w Data Maybe [t] 

We may add the given in the inert set, along with its superclasses
[assuming we don't fail because there is a matching instance, see 
 tryTopReact, given case ]
  Inert:
    d0 :_g Foo t 
  WorkList 
    d01 :_g Data Maybe t  -- d2 := EvDictSuperClass d0 0 
    d1 :_w Data Maybe [t] 
Then d2 can readily enter the inert, and we also do solving of the wanted
  Inert: 
    d0 :_g Foo t 
    d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3 
  WorkList
    d2 :_w Sat (Maybe [t])          
    d3 :_w Data Maybe t
    d01 :_g Data Maybe t 
Now, we may simplify d2 more: 
  Inert:
      d0 :_g Foo t 
      d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3 
      d1 :_g Data Maybe [t] 
      d2 :_g Sat (Maybe [t])          d2 := dfunSat d4 
  WorkList: 
      d3 :_w Data Maybe t 
      d4 :_w Foo [t] 
      d01 :_g Data Maybe t 

Now, we can just solve d3.
  Inert
      d0 :_g Foo t 
      d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3 
      d2 :_g Sat (Maybe [t])          d2 := dfunSat d4 
  WorkList
      d4 :_w Foo [t] 
      d01 :_g Data Maybe t 
And now we can simplify d4 again, but since it has superclasses we *add* them to the worklist:
  Inert
      d0 :_g Foo t 
      d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3 
      d2 :_g Sat (Maybe [t])          d2 := dfunSat d4 
      d4 :_g Foo [t]                  d4 := dfunFoo2 d5 
  WorkList:
      d5 :_w Foo t 
      d6 :_g Data Maybe [t]           d6 := EvDictSuperClass d4 0
      d01 :_g Data Maybe t 
Now, d5 can be solved! (and its superclass enter scope) 
  Inert
      d0 :_g Foo t 
      d1 :_s Data Maybe [t]           d1 := dfunData2 d2 d3 
      d2 :_g Sat (Maybe [t])          d2 := dfunSat d4 
      d4 :_g Foo [t]                  d4 := dfunFoo2 d5 
      d5 :_g Foo t                    d5 := dfunFoo1 d7
  WorkList:
      d7 :_w Data Maybe t
      d6 :_g Data Maybe [t]
      d8 :_g Data Maybe t            d8 := EvDictSuperClass d5 0
      d01 :_g Data Maybe t 

Now, two problems: 
   [1] Suppose we pick d8 and we react him with d01. Which of the two givens should 
       we keep? Well, we *MUST NOT* drop d01 because d8 contains recursive evidence 
       that must not be used (look at case interactInert where both inert and workitem
       are givens). So we have several options: 
       - Drop the workitem always (this will drop d8)
              This feels very unsafe -- what if the work item was the "good" one
              that should be used later to solve another wanted?
       - Don't drop anyone: the inert set may contain multiple givens! 
              [This is currently implemented] 

The "don't drop anyone" seems the most safe thing to do, so now we come to problem 2: 
  [2] We have added both d6 and d01 in the inert set, and we are interacting our wanted
      d7. Now the [isRecDictEv] function in the ineration solver 
      [case inert-given workitem-wanted] will prevent us from interacting d7 := d8 
      precisely because chasing the evidence of d8 leads us to an unguarded use of d7. 

      So, no interaction happens there. Then we meet d01 and there is no recursion 
      problem there [isRectDictEv] gives us the OK to interact and we do solve d7 := d01! 
             
Note [SUPERCLASS-LOOP 1]
~~~~~~~~~~~~~~~~~~~~~~~~
We have to be very, very careful when generating superclasses, lest we
accidentally build a loop. Here's an example:

  class S a

  class S a => C a where { opc :: a -> a }
  class S b => D b where { opd :: b -> b }
  
  instance C Int where
     opc = opd
  
  instance D Int where
     opd = opc

From (instance C Int) we get the constraint set {ds1:S Int, dd:D Int}
Simplifying, we may well get:
	$dfCInt = :C ds1 (opd dd)
	dd  = $dfDInt
	ds1 = $p1 dd
Notice that we spot that we can extract ds1 from dd.  

Alas!  Alack! We can do the same for (instance D Int):

	$dfDInt = :D ds2 (opc dc)
	dc  = $dfCInt
	ds2 = $p1 dc

And now we've defined the superclass in terms of itself.
Two more nasty cases are in
	tcrun021
	tcrun033

Solution: 
  - Satisfy the superclass context *all by itself* 
    (tcSimplifySuperClasses)
  - And do so completely; i.e. no left-over constraints
    to mix with the constraints arising from method declarations


Note [SUPERCLASS-LOOP 2]
~~~~~~~~~~~~~~~~~~~~~~~~
We need to be careful when adding "the constaint we are trying to prove".
Suppose we are *given* d1:Ord a, and want to deduce (d2:C [a]) where

	class Ord a => C a where
	instance Ord [a] => C [a] where ...

Then we'll use the instance decl to deduce C [a] from Ord [a], and then add the
superclasses of C [a] to avails.  But we must not overwrite the binding
for Ord [a] (which is obtained from Ord a) with a superclass selection or we'll just
build a loop! 

Here's another variant, immortalised in tcrun020
	class Monad m => C1 m
	class C1 m => C2 m x
	instance C2 Maybe Bool
For the instance decl we need to build (C1 Maybe), and it's no good if
we run around and add (C2 Maybe Bool) and its superclasses to the avails 
before we search for C1 Maybe.

Here's another example 
 	class Eq b => Foo a b
	instance Eq a => Foo [a] a
If we are reducing
	(Foo [t] t)

we'll first deduce that it holds (via the instance decl).  We must not
then overwrite the Eq t constraint with a superclass selection!

At first I had a gross hack, whereby I simply did not add superclass constraints
in addWanted, though I did for addGiven and addIrred.  This was sub-optimal,
becuase it lost legitimate superclass sharing, and it still didn't do the job:
I found a very obscure program (now tcrun021) in which improvement meant the
simplifier got two bites a the cherry... so something seemed to be an Stop
first time, but reducible next time.

Now we implement the Right Solution, which is to check for loops directly 
when adding superclasses.  It's a bit like the occurs check in unification.

Note [Recursive instances and superclases]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this code, which arises in the context of "Scrap Your 
Boilerplate with Class".  

    class Sat a
    class Data ctx a
    instance  Sat (ctx Char)             => Data ctx Char
    instance (Sat (ctx [a]), Data ctx a) => Data ctx [a]

    class Data Maybe a => Foo a

    instance Foo t => Sat (Maybe t)

    instance Data Maybe a => Foo a
    instance Foo a        => Foo [a]
    instance                 Foo [Char]

In the instance for Foo [a], when generating evidence for the superclasses
(ie in tcSimplifySuperClasses) we need a superclass (Data Maybe [a]).
Using the instance for Data, we therefore need
        (Sat (Maybe [a], Data Maybe a)
But we are given (Foo a), and hence its superclass (Data Maybe a).
So that leaves (Sat (Maybe [a])).  Using the instance for Sat means
we need (Foo [a]).  And that is the very dictionary we are bulding
an instance for!  So we must put that in the "givens".  So in this
case we have
	Given:  Foo a, Foo [a]
	Wanted: Data Maybe [a]

BUT we must *not not not* put the *superclasses* of (Foo [a]) in
the givens, which is what 'addGiven' would normally do. Why? Because
(Data Maybe [a]) is the superclass, so we'd "satisfy" the wanted 
by selecting a superclass from Foo [a], which simply makes a loop.

On the other hand we *must* put the superclasses of (Foo a) in
the givens, as you can see from the derivation described above.

Conclusion: in the very special case of tcSimplifySuperClasses
we have one 'given' (namely the "this" dictionary) whose superclasses
must not be added to 'givens' by addGiven.  

There is a complication though.  Suppose there are equalities
      instance (Eq a, a~b) => Num (a,b)
Then we normalise the 'givens' wrt the equalities, so the original
given "this" dictionary is cast to one of a different type.  So it's a
bit trickier than before to identify the "special" dictionary whose
superclasses must not be added. See test
   indexed-types/should_run/EqInInstance

We need a persistent property of the dictionary to record this
special-ness.  Current I'm using the InstLocOrigin (a bit of a hack,
but cool), which is maintained by dictionary normalisation.
Specifically, the InstLocOrigin is
	     NoScOrigin
then the no-superclass thing kicks in.  WATCH OUT if you fiddle
with InstLocOrigin!

Note [MATCHING-SYNONYMS]
~~~~~~~~~~~~~~~~~~~~~~~~
When trying to match a dictionary (D tau) to a top-level instance, or a 
type family equation (F taus_1 ~ tau_2) to a top-level family instance, 
we do *not* need to expand type synonyms because the matcher will do that for us.


Note [RHS-FAMILY-SYNONYMS] 
~~~~~~~~~~~~~~~~~~~~~~~~~~
The RHS of a family instance is represented as yet another constructor which is 
like a type synonym for the real RHS the programmer declared. Eg: 
    type instance F (a,a) = [a] 
Becomes: 
    :R32 a = [a]      -- internal type synonym introduced
    F (a,a) ~ :R32 a  -- instance 

When we react a family instance with a type family equation in the work list 
we keep the synonym-using RHS without expansion. 


*********************************************************************************
*                                                                               * 
                       The top-reaction Stage
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><a name="topReactionsStage"></a><span class='hs-definition'>topReactionsStage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplifierStage</span> 
<a name="line-3"></a><span class='hs-definition'>topReactionsStage</span> <span class='hs-varid'>workItem</span> 
<a name="line-4"></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tryTopReact</span> <span class='hs-varid'>workItem</span> 
<a name="line-5"></a>   
<a name="line-6"></a>
<a name="line-7"></a><a name="tryTopReact"></a><span class='hs-definition'>tryTopReact</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>StopOrContinue</span>
<a name="line-8"></a><span class='hs-definition'>tryTopReact</span> <span class='hs-varid'>wi</span> 
<a name="line-9"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-10"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>ctxt</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSContext</span>
<a name="line-11"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>simplEqsOnly</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- or Stop?</span>
<a name="line-12"></a>        <span class='hs-keyword'>else</span> 
<a name="line-13"></a>            <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>doTopReact</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>wi</span>
<a name="line-14"></a>               <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tir</span> <span class='hs-keyword'>of</span> 
<a name="line-15"></a>                   <span class='hs-conid'>NoTopInt</span> 
<a name="line-16"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span>
<a name="line-17"></a>                   <span class='hs-conid'>SomeTopInt</span> <span class='hs-varid'>rule</span> <span class='hs-varid'>what_next</span> 
<a name="line-18"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bumpStepCountTcS</span> 
<a name="line-19"></a>                             <span class='hs-layout'>;</span> <span class='hs-varid'>traceFireTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_depth</span> <span class='hs-varid'>wi</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-20"></a>                               <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Top react:"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-varid'>rule</span>
<a name="line-21"></a>                             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>what_next</span> <span class='hs-layout'>}</span>
<a name="line-22"></a>               <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-23"></a>
<a name="line-24"></a><a name="TopInteractResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TopInteractResult</span> 
<a name="line-25"></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoTopInt</span>
<a name="line-26"></a> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span><span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StopOrContinue</span> <span class='hs-layout'>}</span>
<a name="line-27"></a>
<a name="line-28"></a>
<a name="line-29"></a><a name="doTopReact"></a><span class='hs-definition'>doTopReact</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WorkItem</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TopInteractResult</span>
<a name="line-30"></a>
<a name="line-31"></a><span class='hs-comment'>-- The work item does not react with the inert set, so try interaction</span>
<a name="line-32"></a><span class='hs-comment'>-- with top-level instances </span>
<a name="line-33"></a><span class='hs-comment'>-- NB: The place to add superclasses in *not*</span>
<a name="line-34"></a><span class='hs-comment'>-- in doTopReact stage. Instead superclasses are added in the worklist</span>
<a name="line-35"></a><span class='hs-comment'>-- as part of the canonicalisation process. See Note [Adding superclasses].</span>
<a name="line-36"></a>
<a name="line-37"></a>
<a name="line-38"></a><span class='hs-comment'>-- Given dictionary</span>
<a name="line-39"></a><span class='hs-comment'>-- See Note [Given constraint that matches an instance declaration]</span>
<a name="line-40"></a><span class='hs-definition'>doTopReact</span> <span class='hs-sel'>_inerts</span> <span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Given</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-41"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoTopInt</span> <span class='hs-comment'>-- NB: Superclasses already added since it's canonical</span>
<a name="line-42"></a>
<a name="line-43"></a><span class='hs-comment'>-- Derived dictionary: just look for functional dependencies</span>
<a name="line-44"></a><span class='hs-definition'>doTopReact</span> <span class='hs-sel'>_inerts</span> <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Derived</span> <span class='hs-varid'>loc</span>
<a name="line-45"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-46"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>instEnvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getInstEnvs</span>
<a name="line-47"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>improveFromInstEnv</span> <span class='hs-varid'>instEnvs</span>
<a name="line-48"></a>                           <span class='hs-layout'>(</span><span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprArisingAt</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span>
<a name="line-49"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteWithFunDeps</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-varid'>xis</span> <span class='hs-varid'>loc</span>
<a name="line-50"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>of</span>
<a name="line-51"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoTopInt</span>
<a name="line-52"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis'</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>fd_work</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-53"></a>               <span class='hs-keyword'>let</span> <span class='hs-varid'>workItem'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis'</span> <span class='hs-layout'>}</span>
<a name="line-54"></a>                   <span class='hs-comment'>-- Deriveds are not supposed to have identity (cc_id is unused!)</span>
<a name="line-55"></a>               <span class='hs-keyword'>in</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>emitFDWorkAsDerived</span> <span class='hs-varid'>fd_work</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_depth</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-56"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-57"></a>                       <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span>  <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Derived Cls fundeps"</span> 
<a name="line-58"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>workItem'</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-59"></a>       <span class='hs-layout'>}</span>
<a name="line-60"></a>
<a name="line-61"></a><span class='hs-comment'>-- Wanted dictionary</span>
<a name="line-62"></a><span class='hs-definition'>doTopReact</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Wanted</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span>
<a name="line-63"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-64"></a>  <span class='hs-comment'>-- See Note [MATCHING-SYNONYMS]</span>
<a name="line-65"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"doTopReact"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-66"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>instEnvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getInstEnvs</span>
<a name="line-67"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>improveFromInstEnv</span> <span class='hs-varid'>instEnvs</span> 
<a name="line-68"></a>                            <span class='hs-layout'>(</span><span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprArisingAt</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span>
<a name="line-69"></a>
<a name="line-70"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>any_fundeps</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteWithFunDeps</span> <span class='hs-varid'>fd_eqns</span> <span class='hs-varid'>xis</span> <span class='hs-varid'>loc</span>
<a name="line-71"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>any_fundeps</span> <span class='hs-keyword'>of</span>
<a name="line-72"></a>           <span class='hs-comment'>-- No Functional Dependencies</span>
<a name="line-73"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-74"></a>               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>lkup_inst_res</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchClassInst</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span> <span class='hs-varid'>loc</span>
<a name="line-75"></a>                  <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lkup_inst_res</span> <span class='hs-keyword'>of</span>
<a name="line-76"></a>                      <span class='hs-conid'>GenInst</span> <span class='hs-varid'>wtvs</span> <span class='hs-varid'>ev_term</span>
<a name="line-77"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>doSolveFromInstance</span> <span class='hs-varid'>wtvs</span> <span class='hs-varid'>ev_term</span> <span class='hs-varid'>workItem</span>
<a name="line-78"></a>                      <span class='hs-conid'>NoInstance</span>
<a name="line-79"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoTopInt</span>
<a name="line-80"></a>                  <span class='hs-layout'>}</span>
<a name="line-81"></a>           <span class='hs-comment'>-- Actual Functional Dependencies</span>
<a name="line-82"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-sel'>_xis'</span><span class='hs-layout'>,</span><span class='hs-sel'>_cos</span><span class='hs-layout'>,</span><span class='hs-varid'>fd_work</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-83"></a>               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>emitFDWorkAsDerived</span> <span class='hs-varid'>fd_work</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_depth</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-84"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Dict/Top (fundeps)"</span>
<a name="line-85"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-86"></a>
<a name="line-87"></a>   <span class='hs-keyword'>where</span> <span class='hs-varid'>doSolveFromInstance</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>WantedEvVar</span><span class='hs-keyglyph'>]</span> 
<a name="line-88"></a>                             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EvTerm</span> 
<a name="line-89"></a>                             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> 
<a name="line-90"></a>                             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TopInteractResult</span>
<a name="line-91"></a>         <span class='hs-comment'>-- Precondition: evidence term matches the predicate of cc_id of workItem</span>
<a name="line-92"></a>         <span class='hs-varid'>doSolveFromInstance</span> <span class='hs-varid'>wtvs</span> <span class='hs-varid'>ev_term</span> <span class='hs-varid'>workItem</span>
<a name="line-93"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>wtvs</span>
<a name="line-94"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"doTopReact/found nullary instance for"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_id</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-95"></a>                 <span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_id</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span> <span class='hs-varid'>ev_term</span> <span class='hs-varid'>fl</span>
<a name="line-96"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-97"></a>                   <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Dict/Top (solved, no new work)"</span> 
<a name="line-98"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-comment'>-- Don't put him in the inerts</span>
<a name="line-99"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> 
<a name="line-100"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"doTopReact/found non-nullary instance for"</span> <span class='hs-varop'>$</span> 
<a name="line-101"></a>                   <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_id</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span>
<a name="line-102"></a>                 <span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_id</span> <span class='hs-varid'>workItem</span><span class='hs-layout'>)</span> <span class='hs-varid'>ev_term</span> <span class='hs-varid'>fl</span>
<a name="line-103"></a>                        <span class='hs-comment'>-- Solved and new wanted work produced, you may cache the </span>
<a name="line-104"></a>                        <span class='hs-comment'>-- (tentatively solved) dictionary as Solved given.</span>
<a name="line-105"></a><span class='hs-comment'>--                 ; let _solved = workItem { cc_flavor = solved_fl }</span>
<a name="line-106"></a><span class='hs-comment'>--                       solved_fl = mkSolvedFlavor fl UnkSkol</span>
<a name="line-107"></a>                 <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ct_from_wev</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvVarX</span> <span class='hs-varid'>v</span> <span class='hs-varid'>fl</span><span class='hs-layout'>)</span>
<a name="line-108"></a>                           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Wanted</span> <span class='hs-varid'>fl</span>
<a name="line-109"></a>                                           <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_depth</span> <span class='hs-varid'>workItem</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span> <span class='hs-layout'>}</span>
<a name="line-110"></a>                       <span class='hs-varid'>wtvs_cts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>ct_from_wev</span> <span class='hs-varid'>wtvs</span>
<a name="line-111"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>appendWorkListCt</span> <span class='hs-varid'>wtvs_cts</span><span class='hs-layout'>)</span>
<a name="line-112"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span>
<a name="line-113"></a>                   <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span>     <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Dict/Top (solved, more work)"</span>
<a name="line-114"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span>
<a name="line-115"></a>                 <span class='hs-layout'>}</span>
<a name="line-116"></a><span class='hs-comment'>--                              , tir_new_item = ContinueWith solved } } -- Cache in inerts the Solved item</span>
<a name="line-117"></a>
<a name="line-118"></a><span class='hs-comment'>-- Type functions</span>
<a name="line-119"></a><span class='hs-definition'>doTopReact</span> <span class='hs-sel'>_inerts</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-120"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>GivenSolved</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isGiven_maybe</span> <span class='hs-varid'>fl</span>
<a name="line-121"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoTopInt</span> <span class='hs-comment'>-- If Solved, no more interactions should happen</span>
<a name="line-122"></a>
<a name="line-123"></a><span class='hs-comment'>-- Otherwise, it's a Given, Derived, or Wanted</span>
<a name="line-124"></a><span class='hs-definition'>doTopReact</span> <span class='hs-sel'>_inerts</span> <span class='hs-varid'>workItem</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span>
<a name="line-125"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-126"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSynFamilyTyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- No associated data families have reached that far </span>
<a name="line-127"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>match_res</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchFam</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>args</span>   <span class='hs-comment'>-- See Note [MATCHING-SYNONYMS]</span>
<a name="line-128"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>match_res</span> <span class='hs-keyword'>of</span> 
<a name="line-129"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoTopInt</span> 
<a name="line-130"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>rep_tys</span><span class='hs-layout'>)</span>
<a name="line-131"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>coe_tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConFamilyCoercion_maybe</span> <span class='hs-varid'>rep_tc</span>
<a name="line-132"></a>                         <span class='hs-conid'>Just</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcView</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>rep_tc</span> <span class='hs-varid'>rep_tys</span><span class='hs-layout'>)</span>
<a name="line-133"></a>			    <span class='hs-comment'>-- Eagerly expand away the type synonym on the</span>
<a name="line-134"></a>			    <span class='hs-comment'>-- RHS of a type function, so that it never</span>
<a name="line-135"></a>			    <span class='hs-comment'>-- appears in an error message</span>
<a name="line-136"></a>                            <span class='hs-comment'>-- See Note [Type synonym families] in TyCon</span>
<a name="line-137"></a>                         <span class='hs-varid'>coe</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcAxInstCo</span> <span class='hs-varid'>coe_tc</span> <span class='hs-varid'>rep_tys</span> 
<a name="line-138"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fl</span> <span class='hs-keyword'>of</span>
<a name="line-139"></a>                       <span class='hs-conid'>Wanted</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>evc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEqVar</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>xi</span> <span class='hs-comment'>-- Wanted version</span>
<a name="line-140"></a>                                       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>eqv'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>evc</span>
<a name="line-141"></a>                                       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>coercion</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coe</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv'</span>
<a name="line-142"></a>                                       <span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>coercion</span> <span class='hs-varid'>fl</span>
<a name="line-143"></a>                                       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNewEvVar</span> <span class='hs-varid'>evc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> 
<a name="line-144"></a>                                            <span class='hs-layout'>(</span><span class='hs-keyword'>let</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv'</span>
<a name="line-145"></a>                                                                    <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span> 
<a name="line-146"></a>                                                                    <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_depth</span> <span class='hs-varid'>workItem</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>}</span> 
<a name="line-147"></a>                                             <span class='hs-keyword'>in</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEq</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-148"></a>
<a name="line-149"></a>                                       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-sel'>_solved</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solved_fl</span> <span class='hs-layout'>}</span>
<a name="line-150"></a>                                             <span class='hs-varid'>solved_fl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSolvedFlavor</span> <span class='hs-varid'>fl</span> <span class='hs-conid'>UnkSkol</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-varid'>coercion</span><span class='hs-layout'>)</span>
<a name="line-151"></a>
<a name="line-152"></a>                                       <span class='hs-layout'>;</span> <span class='hs-varid'>updateFlatCache</span> <span class='hs-varid'>eqv</span> <span class='hs-varid'>solved_fl</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>args</span> <span class='hs-varid'>xi</span> <span class='hs-conid'>WhenSolved</span>
<a name="line-153"></a>
<a name="line-154"></a>                                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-155"></a>                                         <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Fun/Top (solved, more work)"</span>
<a name="line-156"></a>                                                    <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-157"></a>                                                  <span class='hs-comment'>--  , tir_new_item = ContinueWith solved } }</span>
<a name="line-158"></a>                                                     <span class='hs-comment'>-- Cache in inerts the Solved item</span>
<a name="line-159"></a>
<a name="line-160"></a>                       <span class='hs-conid'>Given</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>fl'</span><span class='hs-layout'>,</span><span class='hs-varid'>eqv'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newGivenEqVar</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varop'>$</span> 
<a name="line-161"></a>                                                         <span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>eqv</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>coe</span>
<a name="line-162"></a>                                      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv'</span>
<a name="line-163"></a>                                                               <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl'</span>
<a name="line-164"></a>                                                               <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_depth</span> <span class='hs-varid'>workItem</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>}</span>  
<a name="line-165"></a>                                      <span class='hs-layout'>;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEq</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span> 
<a name="line-166"></a>
<a name="line-167"></a>                                      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-168"></a>                                        <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Fun/Top (given)"</span>
<a name="line-169"></a>                                                   <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>workItem</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-170"></a>                       <span class='hs-conid'>Derived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>evc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEvVar</span> <span class='hs-varid'>fl</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkEqPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-171"></a>                                        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>eqv'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>evc</span>
<a name="line-172"></a>                                        <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNewEvVar</span> <span class='hs-varid'>evc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> 
<a name="line-173"></a>                                            <span class='hs-layout'>(</span><span class='hs-keyword'>let</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqv'</span>
<a name="line-174"></a>                                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span>
<a name="line-175"></a>                                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_depth</span> <span class='hs-varid'>workItem</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span> <span class='hs-layout'>}</span> 
<a name="line-176"></a>                                             <span class='hs-keyword'>in</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendWorkListEq</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> 
<a name="line-177"></a>                                        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-178"></a>                                          <span class='hs-conid'>SomeTopInt</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tir_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Fun/Top (derived)"</span>
<a name="line-179"></a>                                                     <span class='hs-layout'>,</span> <span class='hs-varid'>tir_new_item</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-180"></a>                   <span class='hs-layout'>}</span>
<a name="line-181"></a>       <span class='hs-layout'>}</span>
<a name="line-182"></a>
<a name="line-183"></a>
<a name="line-184"></a><span class='hs-comment'>-- Any other work item does not react with any top-level equations</span>
<a name="line-185"></a><span class='hs-definition'>doTopReact</span> <span class='hs-sel'>_inerts</span> <span class='hs-sel'>_workItem</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoTopInt</span> 
</pre>\end{code}


Note [FunDep and implicit parameter reactions] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Currently, our story of interacting two dictionaries (or a dictionary
and top-level instances) for functional dependencies, and implicit
paramters, is that we simply produce new wanted equalities.  So for example

        class D a b | a -> b where ... 
    Inert: 
        d1 :g D Int Bool
    WorkItem: 
        d2 :w D Int alpha

    We generate the extra work item
        cv :w alpha ~ Bool
    where 'cv' is currently unused.  However, this new item reacts with d2,
    discharging it in favour of a new constraint d2' thus:
        d2' :w D Int Bool
	d2 := d2' |> D Int cv
    Now d2' can be discharged from d1

We could be more aggressive and try to *immediately* solve the dictionary 
using those extra equalities. With the same inert set and work item we
might dischard d2 directly:

        cv :w alpha ~ Bool
        d2 := d1 |> D Int cv

But in general it's a bit painful to figure out the necessary coercion,
so we just take the first approach. Here is a better example. Consider:
    class C a b c | a -> b 
And: 
     [Given]  d1 : C T Int Char 
     [Wanted] d2 : C T beta Int 
In this case, it's *not even possible* to solve the wanted immediately. 
So we should simply output the functional dependency and add this guy
[but NOT its superclasses] back in the worklist. Even worse: 
     [Given] d1 : C T Int beta 
     [Wanted] d2: C T beta Int 
Then it is solvable, but its very hard to detect this on the spot. 

It's exactly the same with implicit parameters, except that the
"aggressive" approach would be much easier to implement.

Note [When improvement happens]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We fire an improvement rule when

  * Two constraints match (modulo the fundep)
      e.g. C t1 t2, C t1 t3    where C a b | a->b
    The two match because the first arg is identical

  * At least one is not Given.  If they are both given, we don't fire
    the reaction because we have no way of constructing evidence for a
    new equality nor does it seem right to create a new wanted goal
    (because the goal will most likely contain untouchables, which
    can't be solved anyway)!
   
Note that we *do* fire the improvement if one is Given and one is Derived.
The latter can be a superclass of a wanted goal. Example (tcfail138)
    class L a b | a -> b
    class (G a, L a b) => C a b

    instance C a b' => G (Maybe a)
    instance C a b  => C (Maybe a) a
    instance L (Maybe a) a

When solving the superclasses of the (C (Maybe a) a) instance, we get
  Given:  C a b  ... and hance by superclasses, (G a, L a b)
  Wanted: G (Maybe a)
Use the instance decl to get
  Wanted: C a b'
The (C a b') is inert, so we generate its Derived superclasses (L a b'),
and now we need improvement between that derived superclass an the Given (L a b)

Note [Overriding implicit parameters]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider
   f :: (?x::a) -> Bool -> a
  
   g v = let ?x::Int = 3 
         in (f v, let ?x::Bool = True in f v)

This should probably be well typed, with
   g :: Bool -> (Int, Bool)

So the inner binding for ?x::Bool *overrides* the outer one.
Hence a work-item Given overrides an inert-item Given.

Note [Given constraint that matches an instance declaration]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
What should we do when we discover that one (or more) top-level 
instances match a given (or solved) class constraint? We have 
two possibilities:

  1. Reject the program. The reason is that there may not be a unique
     best strategy for the solver. Example, from the OutsideIn(X) paper:
       instance P x => Q [x] 
       instance (x ~ y) => R [x] y 
     
       wob :: forall a b. (Q [b], R b a) => a -> Int 

       g :: forall a. Q [a] => [a] -> Int 
       g x = wob x 

       will generate the impliation constraint: 
            Q [a] => (Q [beta], R beta [a]) 
       If we react (Q [beta]) with its top-level axiom, we end up with a 
       (P beta), which we have no way of discharging. On the other hand, 
       if we react R beta [a] with the top-level we get  (beta ~ a), which 
       is solvable and can help us rewrite (Q [beta]) to (Q [a]) which is 
       now solvable by the given Q [a]. 
 
     However, this option is restrictive, for instance [Example 3] from 
     Note [Recursive instances and superclases] will fail to work. 

  2. Ignore the problem, hoping that the situations where there exist indeed
     such multiple strategies are rare: Indeed the cause of the previous 
     problem is that (R [x] y) yields the new work (x ~ y) which can be 
     *spontaneously* solved, not using the givens. 

We are choosing option 2 below but we might consider having a flag as well.


Note [New Wanted Superclass Work] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Even in the case of wanted constraints, we may add some superclasses 
as new given work. The reason is: 

        To allow FD-like improvement for type families. Assume that 
        we have a class 
             class C a b | a -> b 
        and we have to solve the implication constraint: 
             C a b => C a beta 
        Then, FD improvement can help us to produce a new wanted (beta ~ b) 

        We want to have the same effect with the type family encoding of 
        functional dependencies. Namely, consider: 
             class (F a ~ b) => C a b 
        Now suppose that we have: 
               given: C a b 
               wanted: C a beta 
        By interacting the given we will get given (F a ~ b) which is not 
        enough by itself to make us discharge (C a beta). However, we 
        may create a new derived equality from the super-class of the
        wanted constraint (C a beta), namely derived (F a ~ beta). 
        Now we may interact this with given (F a ~ b) to get: 
                  derived :  beta ~ b 
        But 'beta' is a touchable unification variable, and hence OK to 
        unify it with 'b', replacing the derived evidence with the identity. 

        This requires trySpontaneousSolve to solve *derived*
        equalities that have a touchable in their RHS, *in addition*
        to solving wanted equalities.

We also need to somehow use the superclasses to quantify over a minimal, 
constraint see note [Minimize by Superclasses] in TcSimplify.


Finally, here is another example where this is useful. 

Example 1:
----------
   class (F a ~ b) => C a b 
And we are given the wanteds:
      w1 : C a b 
      w2 : C a c 
      w3 : b ~ c 
We surely do *not* want to quantify over (b ~ c), since if someone provides
dictionaries for (C a b) and (C a c), these dictionaries can provide a proof 
of (b ~ c), hence no extra evidence is necessary. Here is what will happen: 

     Step 1: We will get new *given* superclass work, 
             provisionally to our solving of w1 and w2
             
               g1: F a ~ b, g2 : F a ~ c, 
               w1 : C a b, w2 : C a c, w3 : b ~ c

             The evidence for g1 and g2 is a superclass evidence term: 

               g1 := sc w1, g2 := sc w2

     Step 2: The givens will solve the wanted w3, so that 
               w3 := sym (sc w1) ; sc w2 
                  
     Step 3: Now, one may naively assume that then w2 can be solve from w1
             after rewriting with the (now solved equality) (b ~ c). 
             
             But this rewriting is ruled out by the isGoodRectDict! 

Conclusion, we will (correctly) end up with the unsolved goals 
    (C a b, C a c)   

NB: The desugarer needs be more clever to deal with equalities 
    that participate in recursive dictionary bindings. 

\begin{code}
<pre><a name="line-1"></a><a name="LookupInstResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>LookupInstResult</span>
<a name="line-2"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoInstance</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GenInst</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>WantedEvVar</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>EvTerm</span> 
<a name="line-4"></a>
<a name="line-5"></a><a name="matchClassInst"></a><span class='hs-definition'>matchClassInst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>LookupInstResult</span>
<a name="line-6"></a><span class='hs-definition'>matchClassInst</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>loc</span>
<a name="line-7"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span> 
<a name="line-8"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>mb_result</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchClass</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span>
<a name="line-9"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUntouchables</span>
<a name="line-10"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_result</span> <span class='hs-keyword'>of</span>
<a name="line-11"></a>            <span class='hs-conid'>MatchInstNo</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoInstance</span>
<a name="line-12"></a>            <span class='hs-conid'>MatchInstMany</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoInstance</span> <span class='hs-comment'>-- defer any reactions of a multitude until</span>
<a name="line-13"></a>                                               <span class='hs-comment'>-- we learn more about the reagent </span>
<a name="line-14"></a>            <span class='hs-conid'>MatchInstSingle</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-15"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>given_overlap</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>-&gt;</span> 
<a name="line-16"></a>                  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Delaying instance application"</span> <span class='hs-varop'>$</span> 
<a name="line-17"></a>                       <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Workitem="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprType</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-18"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Relevant given dictionaries="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>givens_for_this_clas</span> <span class='hs-keyglyph'>]</span>
<a name="line-19"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoInstance</span> <span class='hs-comment'>-- see Note [Instance and Given overlap]</span>
<a name="line-20"></a>                     <span class='hs-layout'>}</span>
<a name="line-21"></a>
<a name="line-22"></a>            <span class='hs-conid'>MatchInstSingle</span> <span class='hs-layout'>(</span><span class='hs-varid'>dfun_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>mb_inst_tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-23"></a>              <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkWellStagedDFun</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>loc</span>
<a name="line-24"></a>
<a name="line-25"></a> 	<span class='hs-comment'>-- It's possible that not all the tyvars are in</span>
<a name="line-26"></a>	<span class='hs-comment'>-- the substitution, tenv. For example:</span>
<a name="line-27"></a>	<span class='hs-comment'>--	instance C X a =&gt; D X where ...</span>
<a name="line-28"></a>	<span class='hs-comment'>-- (presumably there's a functional dependency in class C)</span>
<a name="line-29"></a>	<span class='hs-comment'>-- Hence mb_inst_tys :: Either TyVar TcType </span>
<a name="line-30"></a>
<a name="line-31"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instDFunTypes</span> <span class='hs-varid'>mb_inst_tys</span>
<a name="line-32"></a>                 <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitPhiTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-33"></a>                 <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span> <span class='hs-keyword'>then</span>
<a name="line-34"></a>                       <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenInst</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvDFunApp</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>tys</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-35"></a>                   <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-36"></a>                     <span class='hs-layout'>{</span> <span class='hs-varid'>evc_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instDFunConstraints</span> <span class='hs-varid'>theta</span> <span class='hs-layout'>(</span><span class='hs-conid'>Wanted</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span>
<a name="line-37"></a>                     <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ev_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>evc_vars</span>
<a name="line-38"></a>                           <span class='hs-varid'>new_evc_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isNewEvVar</span> <span class='hs-varid'>evc_vars</span> 
<a name="line-39"></a>                           <span class='hs-varid'>wevs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EvVarX</span> <span class='hs-layout'>(</span><span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_evc_vars</span>
<a name="line-40"></a>                                  <span class='hs-comment'>-- wevs are only the real new variables that can be emitted </span>
<a name="line-41"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>GenInst</span> <span class='hs-varid'>wevs</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvDFunApp</span> <span class='hs-varid'>dfun_id</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>ev_vars</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-42"></a>                 <span class='hs-layout'>}</span>
<a name="line-43"></a>        <span class='hs-layout'>}</span>
<a name="line-44"></a>   <span class='hs-keyword'>where</span> 
<a name="line-45"></a>     <span class='hs-varid'>givens_for_this_clas</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span>
<a name="line-46"></a>     <span class='hs-varid'>givens_for_this_clas</span> 
<a name="line-47"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupUFM</span> <span class='hs-layout'>(</span><span class='hs-varid'>cts_given</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_dicts</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>clas</span> <span class='hs-varop'>`orElse`</span> <span class='hs-varid'>emptyCts</span>
<a name="line-48"></a>
<a name="line-49"></a>     <span class='hs-varid'>given_overlap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcsUntouchables</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-50"></a>     <span class='hs-varid'>given_overlap</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>matchable</span> <span class='hs-varid'>untch</span><span class='hs-layout'>)</span> <span class='hs-varid'>givens_for_this_clas</span>
<a name="line-51"></a>
<a name="line-52"></a>     <span class='hs-varid'>matchable</span> <span class='hs-varid'>untch</span> <span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>clas_g</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sys</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-53"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>GivenOrig</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isGiven_maybe</span> <span class='hs-varid'>fl</span>
<a name="line-54"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>clas_g</span> <span class='hs-varop'>==</span> <span class='hs-varid'>clas</span> <span class='hs-layout'>)</span>
<a name="line-55"></a>         <span class='hs-keyword'>case</span> <span class='hs-varid'>tcUnifyTys</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>tv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isTouchableMetaTyVar_InRange</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&amp;&amp;</span> 
<a name="line-56"></a>                                    <span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>tys</span>
<a name="line-57"></a>                                 <span class='hs-keyword'>then</span> <span class='hs-conid'>BindMe</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>Skolem</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>sys</span> <span class='hs-keyword'>of</span>
<a name="line-58"></a>       <span class='hs-comment'>-- We can't learn anything more about any variable at this point, so the only</span>
<a name="line-59"></a>       <span class='hs-comment'>-- cause of overlap can be by an instantiation of a touchable unification</span>
<a name="line-60"></a>       <span class='hs-comment'>-- variable. Hence we only bind touchable unification variables. In addition,</span>
<a name="line-61"></a>       <span class='hs-comment'>-- we use tcUnifyTys instead of tcMatchTys to rule out cyclic substitutions.</span>
<a name="line-62"></a>            <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-63"></a>            <span class='hs-conid'>Just</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-64"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- No overlap with a solved, already been taken care of </span>
<a name="line-65"></a>                           <span class='hs-comment'>-- by the overlap check with the instance environment.</span>
<a name="line-66"></a>     <span class='hs-varid'>matchable</span> <span class='hs-sel'>_tys</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"Expecting dictionary!"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Instance and Given overlap]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Assume that we have an inert set that looks as follows:
       [Given] D [Int]
And an instance declaration: 
       instance C a => D [a]
A new wanted comes along of the form: 
       [Wanted] D [alpha]

One possibility is to apply the instance declaration which will leave us 
with an unsolvable goal (C alpha). However, later on a new constraint may 
arise (for instance due to a functional dependency between two later dictionaries), 
that will add the equality (alpha ~ Int), in which case our ([Wanted] D [alpha]) 
will be transformed to [Wanted] D [Int], which could have been discharged by the given. 

The solution is that in matchClassInst and eventually in topReact, we get back with 
a matching instance, only when there is no Given in the inerts which is unifiable to
this particular dictionary.

The end effect is that, much as we do for overlapping instances, we delay choosing a 
class instance if there is a possibility of another instance OR a given to match our 
constraint later on. This fixes bugs #4981 and #5002.

This is arguably not easy to appear in practice due to our aggressive prioritization 
of equality solving over other constraints, but it is possible. I've added a test case 
in typecheck/should-compile/GivenOverlapping.hs

Moreover notice that our goals here are different than the goals of the top-level 
overlapping checks. There we are interested in validating the following principle:
 
    If we inline a function f at a site where the same global instance environment
    is available as the instance environment at the definition site of f then we 
    should get the same behaviour. 

But for the Given Overlap check our goal is just related to completeness of 
constraint solving. 




</body>
</html>
