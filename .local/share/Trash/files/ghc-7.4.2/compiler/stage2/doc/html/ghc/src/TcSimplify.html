<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://www.cs.york.ac.uk/fp/darcs/hscolour/ -->
<title>typecheck/TcSimplify.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>{-# OPTIONS -fno-warn-tabs #-}</span>
<a name="line-2"></a><span class='hs-comment'>-- The above warning supression flag is a temporary kludge.</span>
<a name="line-3"></a><span class='hs-comment'>-- While working on this module you are encouraged to remove it and</span>
<a name="line-4"></a><span class='hs-comment'>-- detab the module (please do the detabbing in a separate patch). See</span>
<a name="line-5"></a><span class='hs-comment'>--     <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces">http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces</a></span>
<a name="line-6"></a><span class='hs-comment'>-- for details</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcSimplify</span><span class='hs-layout'>(</span> 
<a name="line-9"></a>       <span class='hs-varid'>simplifyInfer</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyAmbiguityCheck</span><span class='hs-layout'>,</span>
<a name="line-10"></a>       <span class='hs-varid'>simplifyDefault</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyDeriv</span><span class='hs-layout'>,</span> 
<a name="line-11"></a>       <span class='hs-varid'>simplifyRule</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyTop</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyInteractive</span>
<a name="line-12"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-15"></a>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnMonad</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcErrors</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcMType</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span> 
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span> 
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcInteract</span> 
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Inst</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unify</span>	<span class='hs-layout'>(</span> <span class='hs-varid'>niFixTvSubst</span><span class='hs-layout'>,</span> <span class='hs-varid'>niSubstTvSet</span> <span class='hs-layout'>)</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span> 
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TypeRep</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>NameEnv</span>	<span class='hs-layout'>(</span> <span class='hs-varid'>emptyNameEnv</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ListSetOps</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelInfo</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelNames</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>		<span class='hs-layout'>(</span> <span class='hs-varid'>classKey</span> <span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>       <span class='hs-layout'>(</span> <span class='hs-conid'>RuleName</span> <span class='hs-layout'>)</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>when</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TrieMap</span>
<a name="line-42"></a>
</pre>\end{code}


*********************************************************************************
*                                                                               * 
*                           External interface                                  *
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="simplifyTop"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-comment'>-- Simplify top-level constraints</span>
<a name="line-3"></a><span class='hs-comment'>-- Usually these will be implications,</span>
<a name="line-4"></a><span class='hs-comment'>-- but when there is nothing to quantify we don't wrap</span>
<a name="line-5"></a><span class='hs-comment'>-- in a degenerate implication, so we do that here instead</span>
<a name="line-6"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-varid'>wanteds</span> 
<a name="line-7"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplifyCheck</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplCheck</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"top level"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>wanteds</span>
<a name="line-8"></a>
<a name="line-9"></a><a name="simplifyAmbiguityCheck"></a><span class='hs-comment'>------------------</span>
<a name="line-10"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-11"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-varid'>name</span> <span class='hs-varid'>wanteds</span>
<a name="line-12"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplifyCheck</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplCheck</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"ambiguity check for"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>wanteds</span>
<a name="line-13"></a> 
<a name="line-14"></a><a name="simplifyInteractive"></a><span class='hs-comment'>------------------</span>
<a name="line-15"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-16"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-varid'>wanteds</span> 
<a name="line-17"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplifyCheck</span> <span class='hs-conid'>SimplInteractive</span> <span class='hs-varid'>wanteds</span>
<a name="line-18"></a>
<a name="line-19"></a><a name="simplifyDefault"></a><span class='hs-comment'>------------------</span>
<a name="line-20"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ThetaType</span>	<span class='hs-comment'>-- Wanted; has no type variables in it</span>
<a name="line-21"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>	<span class='hs-comment'>-- Succeeds iff the constraint is soluble</span>
<a name="line-22"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-varid'>theta</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFlatWanteds</span> <span class='hs-conid'>DefaultOrigin</span> <span class='hs-varid'>theta</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-sel'>_ignored_ev_binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplifyCheck</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplCheck</span> <span class='hs-layout'>(</span><span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"defaults"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> 
<a name="line-25"></a>                                            <span class='hs-layout'>(</span><span class='hs-varid'>mkFlatWC</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
</pre>\end{code}


***********************************************************************************
*                                                                                 * 
*                            Deriving                                             *
*                                                                                 *
***********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="simplifyDeriv"></a><span class='hs-definition'>simplifyDeriv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtOrigin</span>
<a name="line-2"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span>
<a name="line-3"></a>	      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>	
<a name="line-4"></a>	      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span>		<span class='hs-comment'>-- Wanted</span>
<a name="line-5"></a>	      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>ThetaType</span>	<span class='hs-comment'>-- Needed</span>
<a name="line-6"></a><span class='hs-comment'>-- Given  instance (wanted) =&gt; C inst_ty </span>
<a name="line-7"></a><span class='hs-comment'>-- Simplify 'wanted' as much as possibles</span>
<a name="line-8"></a><span class='hs-comment'>-- Fail if not possible</span>
<a name="line-9"></a><span class='hs-definition'>simplifyDeriv</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> 
<a name="line-10"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tvs_skols</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInstSkolTyVars</span> <span class='hs-varid'>tvs</span> <span class='hs-comment'>-- Skolemize</span>
<a name="line-11"></a>      	 	<span class='hs-comment'>-- The constraint solving machinery </span>
<a name="line-12"></a>		<span class='hs-comment'>-- expects *TcTyVars* not TyVars.  </span>
<a name="line-13"></a>		<span class='hs-comment'>-- We use *non-overlappable* (vanilla) skolems</span>
<a name="line-14"></a>		<span class='hs-comment'>-- See Note [Overlap and deriving]</span>
<a name="line-15"></a>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>skol_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipTopTvSubst</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tvs_skols</span>
<a name="line-17"></a>             <span class='hs-varid'>subst_skol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipTopTvSubst</span> <span class='hs-varid'>tvs_skols</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tvs</span>
<a name="line-18"></a>             <span class='hs-varid'>skol_set</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>tvs_skols</span>
<a name="line-19"></a>	     <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"deriving"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-20"></a>
<a name="line-21"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFlatWanteds</span> <span class='hs-varid'>orig</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTheta</span> <span class='hs-varid'>skol_subst</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-22"></a>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyDeriv"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>theta</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>residual_wanted</span><span class='hs-layout'>,</span> <span class='hs-sel'>_binds</span><span class='hs-layout'>)</span>
<a name="line-25"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplInfer</span> <span class='hs-varid'>doc</span><span class='hs-layout'>)</span> <span class='hs-conid'>NoUntouchables</span> <span class='hs-varop'>$</span>
<a name="line-26"></a>                <span class='hs-varid'>mkFlatWC</span> <span class='hs-varid'>wanted</span>
<a name="line-27"></a>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>good</span><span class='hs-layout'>,</span> <span class='hs-varid'>bad</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBagWith</span> <span class='hs-varid'>get_good</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span>
<a name="line-29"></a>                         <span class='hs-comment'>-- See Note [Exotic derived instance contexts]</span>
<a name="line-30"></a>             <span class='hs-varid'>get_good</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-conid'>PredType</span> <span class='hs-conid'>Ct</span>
<a name="line-31"></a>             <span class='hs-varid'>get_good</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>validDerivPred</span> <span class='hs-varid'>skol_set</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>p</span>
<a name="line-32"></a>                         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>ct</span>
<a name="line-33"></a>                         <span class='hs-keyword'>where</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span>
<a name="line-34"></a>
<a name="line-35"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-layout'>(</span><span class='hs-varid'>residual_wanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bad</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-36"></a>
<a name="line-37"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>min_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>good</span><span class='hs-layout'>)</span>
<a name="line-38"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTheta</span> <span class='hs-varid'>subst_skol</span> <span class='hs-varid'>min_theta</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Overlap and deriving]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider some overlapping instances:
  data Show a => Show [a] where ..
  data Show [Char] where ...

Now a data type with deriving:
  data T a = MkT [a] deriving( Show )

We want to get the derived instance
  instance Show [a] => Show (T a) where...
and NOT
  instance Show a => Show (T a) where...
so that the (Show (T Char)) instance does the Right Thing

It's very like the situation when we're inferring the type
of a function
   f x = show [x]
and we want to infer
   f :: Show [a] => a -> String

BOTTOM LINE: use vanilla, non-overlappable skolems when inferring
             the context for the derived instance. 
	     Hence tcInstSkolTyVars not tcInstSuperSkolTyVars

Note [Exotic derived instance contexts]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In a 'derived' instance declaration, we *infer* the context.  It's a
bit unclear what rules we should apply for this; the Haskell report is
silent.  Obviously, constraints like (Eq a) are fine, but what about
	data T f a = MkT (f a) deriving( Eq )
where we'd get an Eq (f a) constraint.  That's probably fine too.

One could go further: consider
	data T a b c = MkT (Foo a b c) deriving( Eq )
	instance (C Int a, Eq b, Eq c) => Eq (Foo a b c)

Notice that this instance (just) satisfies the Paterson termination 
conditions.  Then we *could* derive an instance decl like this:

	instance (C Int a, Eq b, Eq c) => Eq (T a b c) 
even though there is no instance for (C Int a), because there just
*might* be an instance for, say, (C Int Bool) at a site where we
need the equality instance for T's.  

However, this seems pretty exotic, and it's quite tricky to allow
this, and yet give sensible error messages in the (much more common)
case where we really want that instance decl for C.

So for now we simply require that the derived instance context
should have only type-variable constraints.

Here is another example:
	data Fix f = In (f (Fix f)) deriving( Eq )
Here, if we are prepared to allow -XUndecidableInstances we
could derive the instance
	instance Eq (f (Fix f)) => Eq (Fix f)
but this is so delicate that I don't think it should happen inside
'deriving'. If you want this, write it yourself!

NB: if you want to lift this condition, make sure you still meet the
termination conditions!  If not, the deriving mechanism generates
larger and larger constraints.  Example:
  data Succ a = S a
  data Seq a = Cons a (Seq (Succ a)) | Nil deriving Show

Note the lack of a Show instance for Succ.  First we'll generate
  instance (Show (Succ a), Show a) => Show (Seq a)
and then
  instance (Show (Succ (Succ a)), Show (Succ a), Show a) => Show (Seq a)
and so on.  Instead we want to complain of no instance for (Show (Succ a)).

The bottom line
~~~~~~~~~~~~~~~
Allow constraints which consist only of type variables, with no repeats.

*********************************************************************************
*                                                                                 * 
*                            Inference
*                                                                                 *
***********************************************************************************

Note [Which variables to quantify]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose the inferred type of a function is
   T kappa (alpha:kappa) -> Int
where alpha is a type unification variable and 
      kappa is a kind unification variable
Then we want to quantify over *both* alpha and kappa.  But notice that
kappa appears "at top level" of the type, as well as inside the kind
of alpha.  So it should be fine to just look for the "top level"
kind/type variables of the type, without looking transitively into the
kinds of those type variables.

\begin{code}
<pre><a name="line-1"></a><a name="simplifyInfer"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-2"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>                  <span class='hs-comment'>-- Apply monomorphism restriction</span>
<a name="line-3"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTauType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Variables to be generalised,</span>
<a name="line-4"></a>                                       <span class='hs-comment'>-- and their tau-types</span>
<a name="line-5"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-6"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- Quantify over these type variables</span>
<a name="line-7"></a>                      <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- ... and these constraints</span>
<a name="line-8"></a>		      <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>	    <span class='hs-comment'>-- The monomorphism restriction did something</span>
<a name="line-9"></a>		      		    <span class='hs-comment'>--   so the results type is not as general as</span>
<a name="line-10"></a>				    <span class='hs-comment'>--   it could be</span>
<a name="line-11"></a>                      <span class='hs-conid'>TcEvBinds</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- ... binding these evidence variables</span>
<a name="line-12"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-sel'>_top_lvl</span> <span class='hs-varid'>apply_mr</span> <span class='hs-varid'>name_taus</span> <span class='hs-varid'>wanteds</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-14"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>gbl_tvs</span>     <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>            <span class='hs-comment'>-- Already zonked</span>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_taus</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tvs_to_quantify</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>zonked_taus</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-17"></a>       	     		       <span class='hs-comment'>-- tvs_to_quantify can contain both kind and type vars</span>
<a name="line-18"></a>       	                       <span class='hs-comment'>-- See Note [Which variables to quantify]</span>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkQuantifiedTyVars</span> <span class='hs-varid'>tvs_to_quantify</span>
<a name="line-20"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyTcEvBinds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-21"></a>
<a name="line-22"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>zonked_wanteds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_taus</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>gbl_tvs</span>        <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-26"></a>
<a name="line-27"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInfer {"</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-28"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"names ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span>
<a name="line-29"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"taus (zonked) ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_taus</span>
<a name="line-30"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"gbl_tvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-31"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"closed ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-sel'>_top_lvl</span>
<a name="line-32"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"apply_mr ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>apply_mr</span>
<a name="line-33"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"wanted ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_wanteds</span>
<a name="line-34"></a>             <span class='hs-keyglyph'>]</span>
<a name="line-35"></a>
<a name="line-36"></a>             <span class='hs-comment'>-- Step 1</span>
<a name="line-37"></a>             <span class='hs-comment'>-- Make a guess at the quantified type variables</span>
<a name="line-38"></a>	     <span class='hs-comment'>-- Then split the constraints on the baisis of those tyvars</span>
<a name="line-39"></a>	     <span class='hs-comment'>-- to avoid unnecessarily simplifying a class constraint</span>
<a name="line-40"></a>	     <span class='hs-comment'>-- See Note [Avoid unecessary constraint simplification]</span>
<a name="line-41"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>zonked_taus</span>
<a name="line-42"></a>             <span class='hs-varid'>proto_qtvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growWanteds</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>zonked_wanteds</span> <span class='hs-varop'>$</span>
<a name="line-43"></a>                          <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-44"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>perhaps_bound</span><span class='hs-layout'>,</span> <span class='hs-varid'>surely_free</span><span class='hs-layout'>)</span>
<a name="line-45"></a>                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>quantifyMe</span> <span class='hs-varid'>proto_qtvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>zonked_wanteds</span><span class='hs-layout'>)</span>
<a name="line-46"></a>
<a name="line-47"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInfer proto"</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-48"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"zonked_tau_tvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-49"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"proto_qtvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>proto_qtvs</span>
<a name="line-50"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"surely_fref ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>surely_free</span>
<a name="line-51"></a>             <span class='hs-keyglyph'>]</span>
<a name="line-52"></a>
<a name="line-53"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitWantedCts</span> <span class='hs-varid'>surely_free</span>
<a name="line-54"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"sinf"</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-55"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"perhaps_bound ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>perhaps_bound</span>
<a name="line-56"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"surely_free   ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>surely_free</span>
<a name="line-57"></a>             <span class='hs-keyglyph'>]</span>
<a name="line-58"></a>
<a name="line-59"></a>            <span class='hs-comment'>-- Step 2 </span>
<a name="line-60"></a>       	    <span class='hs-comment'>-- Now simplify the possibly-bound constraints</span>
<a name="line-61"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>simpl_results</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_binds0</span><span class='hs-layout'>)</span>
<a name="line-62"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplInfer</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-conid'>NoUntouchables</span> <span class='hs-varid'>emptyInert</span> <span class='hs-varid'>emptyWorkList</span> <span class='hs-varop'>$</span>
<a name="line-63"></a>              <span class='hs-varid'>simplifyWithApprox</span> <span class='hs-layout'>(</span><span class='hs-varid'>zonked_wanteds</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>perhaps_bound</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-64"></a>
<a name="line-65"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>simpl_results</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Fail fast if there is an insoluble constraint</span>
<a name="line-66"></a>              <span class='hs-layout'>(</span><span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>simpl_results</span><span class='hs-layout'>;</span> <span class='hs-varid'>failM</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-67"></a>
<a name="line-68"></a>            <span class='hs-comment'>-- Step 3 </span>
<a name="line-69"></a>            <span class='hs-comment'>-- Split again simplified_perhaps_bound, because some unifications </span>
<a name="line-70"></a>            <span class='hs-comment'>-- may have happened, and emit the free constraints. </span>
<a name="line-71"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>gbl_tvs</span>        <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-72"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcTyVarsAndFV</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-73"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_simples</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkCts</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>simpl_results</span><span class='hs-layout'>)</span>
<a name="line-74"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>init_tvs</span> 	     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-75"></a>             <span class='hs-varid'>poly_qtvs</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growWantedEVs</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>zonked_simples</span> <span class='hs-varid'>init_tvs</span>
<a name="line-76"></a>	     <span class='hs-layout'>(</span><span class='hs-varid'>pbound</span><span class='hs-layout'>,</span> <span class='hs-varid'>pfree</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>quantifyMe</span> <span class='hs-varid'>poly_qtvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>zonked_simples</span>
<a name="line-77"></a>
<a name="line-78"></a>	     <span class='hs-comment'>-- Monomorphism restriction</span>
<a name="line-79"></a>             <span class='hs-varid'>mr_qtvs</span>  	     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>init_tvs</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>constrained_tvs</span>
<a name="line-80"></a>             <span class='hs-varid'>constrained_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfCts</span> <span class='hs-varid'>zonked_simples</span>
<a name="line-81"></a>	     <span class='hs-varid'>mr_bites</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>apply_mr</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>pbound</span><span class='hs-layout'>)</span>
<a name="line-82"></a>
<a name="line-83"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>bound</span><span class='hs-layout'>,</span> <span class='hs-varid'>free</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-84"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>mr_bites</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mr_qtvs</span><span class='hs-layout'>,</span>   <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>zonked_simples</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-85"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_qtvs</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>pbound</span><span class='hs-layout'>,</span>   <span class='hs-varid'>pfree</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-86"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitWantedCts</span> <span class='hs-varid'>free</span>
<a name="line-87"></a>
<a name="line-88"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyVarSet</span> <span class='hs-varid'>qtvs</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>bound</span>
<a name="line-89"></a>         <span class='hs-keyword'>then</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_insol</span> <span class='hs-varid'>simpl_results</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-90"></a>              <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"} simplifyInfer/no quantification"</span> <span class='hs-varid'>empty</span>
<a name="line-91"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>emitImplications</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_impl</span> <span class='hs-varid'>simpl_results</span><span class='hs-layout'>)</span>
<a name="line-92"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>mr_bites</span><span class='hs-layout'>,</span> <span class='hs-conid'>EvBinds</span> <span class='hs-varid'>tc_binds0</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-93"></a>         <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-94"></a>
<a name="line-95"></a>            <span class='hs-comment'>-- Step 4, zonk quantified variables </span>
<a name="line-96"></a>       <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>minimal_flat_preds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-varop'>$</span> 
<a name="line-97"></a>                                  <span class='hs-varid'>map</span> <span class='hs-varid'>ctPred</span> <span class='hs-varop'>$</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>bound</span>
<a name="line-98"></a>             <span class='hs-varid'>skol_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InferSkol</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkSigmaTy</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>minimal_flat_preds</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-99"></a>                                   <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>name_taus</span> <span class='hs-keyglyph'>]</span>
<a name="line-100"></a>                        <span class='hs-comment'>-- Don't add the quantified variables here, because</span>
<a name="line-101"></a>                        <span class='hs-comment'>-- they are also bound in ic_skols and we want them to be</span>
<a name="line-102"></a>                        <span class='hs-comment'>-- tidied uniformly</span>
<a name="line-103"></a>
<a name="line-104"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtvs_to_return</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkQuantifiedTyVars</span> <span class='hs-varid'>qtvs</span>
<a name="line-105"></a>
<a name="line-106"></a>            <span class='hs-comment'>-- Step 5</span>
<a name="line-107"></a>            <span class='hs-comment'>-- Minimize `bound' and emit an implication</span>
<a name="line-108"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>minimal_bound_ev_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcMType</span><span class='hs-varop'>.</span><span class='hs-varid'>newEvVar</span> <span class='hs-varid'>minimal_flat_preds</span>
<a name="line-109"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-110"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapBagM_</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>EvBind</span> <span class='hs-varid'>evar</span> <span class='hs-varid'>etrm</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addTcEvBind</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>evar</span> <span class='hs-varid'>etrm</span><span class='hs-layout'>)</span> <span class='hs-varid'>tc_binds0</span>
<a name="line-111"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>lcl_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getLclTypeEnv</span>
<a name="line-112"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>gloc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getCtLoc</span> <span class='hs-varid'>skol_info</span>
<a name="line-113"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>implic</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_untch</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUntouchables</span>
<a name="line-114"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_env</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lcl_env</span>
<a name="line-115"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>qtvs_to_return</span>
<a name="line-116"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>minimal_bound_ev_vars</span>
<a name="line-117"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simpl_results</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bound</span> <span class='hs-layout'>}</span>
<a name="line-118"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-119"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-120"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_loc</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gloc</span> <span class='hs-layout'>}</span>
<a name="line-121"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitImplication</span> <span class='hs-varid'>implic</span>
<a name="line-122"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"} simplifyInfer/produced residual implication for quantification"</span> <span class='hs-varop'>$</span>
<a name="line-123"></a>             <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"implic ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>implic</span>
<a name="line-124"></a>                       <span class='hs-comment'>-- ic_skols, ic_given give rest of result</span>
<a name="line-125"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"qtvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs_to_return</span>
<a name="line-126"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"spb ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_simples</span>
<a name="line-127"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"bound ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bound</span> <span class='hs-keyglyph'>]</span>
<a name="line-128"></a>
<a name="line-129"></a>
<a name="line-130"></a>
<a name="line-131"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>qtvs_to_return</span><span class='hs-layout'>,</span> <span class='hs-varid'>minimal_bound_ev_vars</span>
<a name="line-132"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>mr_bites</span><span class='hs-layout'>,</span>  <span class='hs-conid'>TcEvBinds</span> <span class='hs-varid'>ev_binds_var</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
</pre>\end{code}


Note [Minimize by Superclasses]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

When we quantify over a constraint, in simplifyInfer we need to
quantify over a constraint that is minimal in some sense: For
instance, if the final wanted constraint is (Eq alpha, Ord alpha),
we'd like to quantify over Ord alpha, because we can just get Eq alpha
from superclass selection from Ord alpha. This minimization is what
mkMinimalBySCs does. Then, simplifyInfer uses the minimal constraint
to check the original wanted.

\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><a name="simplifyWithApprox"></a><span class='hs-definition'>simplifyWithApprox</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-3"></a><span class='hs-comment'>-- Post: returns only wanteds (no deriveds)</span>
<a name="line-4"></a><span class='hs-definition'>simplifyWithApprox</span> <span class='hs-varid'>wanted</span>
<a name="line-5"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"simplifyApproxLoop"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-6"></a>
<a name="line-7"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_flats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wc_flat</span> <span class='hs-varid'>wanted</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>keepWanted</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_insol</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span> 
<a name="line-8"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-varop'>$</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>all_flats</span>
<a name="line-9"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simpl_loop</span> <span class='hs-num'>1</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_impl</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-10"></a>
<a name="line-11"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>residual_implics</span><span class='hs-layout'>,</span><span class='hs-varid'>floats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>approximateImplications</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-12"></a>
<a name="line-13"></a>      <span class='hs-comment'>-- Solve extra stuff for real: notice that all the extra unsolved constraints will </span>
<a name="line-14"></a>      <span class='hs-comment'>-- be in the inerts of the monad, so we are OK</span>
<a name="line-15"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"simplifyApproxLoop"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Calling solve_wanteds!"</span>
<a name="line-16"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>wants_or_ders</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solve_wanteds</span> <span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floats</span> <span class='hs-comment'>-- They are floated so they are not in the evvar cache</span>
<a name="line-17"></a>                                           <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>residual_implics</span>
<a name="line-18"></a>                                           <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-19"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-20"></a>        <span class='hs-varid'>wants_or_ders</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>keepWanted</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>wants_or_ders</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-21"></a>
<a name="line-22"></a>
<a name="line-23"></a><a name="approximateImplications"></a><span class='hs-definition'>approximateImplications</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cts</span><span class='hs-layout'>)</span>
<a name="line-24"></a><span class='hs-comment'>-- Extracts any nested constraints that don't mention the skolems</span>
<a name="line-25"></a><span class='hs-definition'>approximateImplications</span> <span class='hs-varid'>impls</span>
<a name="line-26"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>do_bag</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_implic</span> <span class='hs-varid'>emptyVarSet</span><span class='hs-layout'>)</span> <span class='hs-varid'>impls</span>
<a name="line-27"></a>  <span class='hs-keyword'>where</span> 
<a name="line-28"></a>    <span class='hs-varid'>do_bag</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-29"></a>    <span class='hs-varid'>do_bag</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>plus</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span>
<a name="line-30"></a>    <span class='hs-varid'>plus</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-31"></a>    <span class='hs-varid'>plus</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span><span class='hs-layout'>,</span><span class='hs-varid'>b1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>a2</span><span class='hs-layout'>,</span><span class='hs-varid'>b2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>a2</span><span class='hs-layout'>,</span> <span class='hs-varid'>b1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>b2</span><span class='hs-layout'>)</span>
<a name="line-32"></a>
<a name="line-33"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cts</span><span class='hs-layout'>)</span>
<a name="line-34"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>imp</span>
<a name="line-35"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>imp</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanted'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>)</span>
<a name="line-36"></a>      <span class='hs-keyword'>where</span>
<a name="line-37"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>wanted'</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-layout'>(</span><span class='hs-varid'>skols</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>ic_skols</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_wanted</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span>
<a name="line-38"></a>
<a name="line-39"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>wc</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flat</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implic</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-40"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flat'</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implic'</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>)</span>
<a name="line-41"></a>      <span class='hs-keyword'>where</span>
<a name="line-42"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>flat'</span><span class='hs-layout'>,</span>   <span class='hs-varid'>floats1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>do_bag</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_flat</span>   <span class='hs-varid'>skols</span><span class='hs-layout'>)</span> <span class='hs-varid'>flat</span>
<a name="line-43"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>implic'</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>do_bag</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_implic</span> <span class='hs-varid'>skols</span><span class='hs-layout'>)</span> <span class='hs-varid'>implic</span>
<a name="line-44"></a>
<a name="line-45"></a>    <span class='hs-varid'>float_flat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cts</span><span class='hs-layout'>)</span>
<a name="line-46"></a>    <span class='hs-varid'>float_flat</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>ct</span>
<a name="line-47"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>skols</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>unitBag</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-48"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                            <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitBag</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span>
</pre>\end{code}

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>-- (growX gbls wanted tvs) grows a seed 'tvs' against the </span>
<a name="line-2"></a><span class='hs-comment'>-- X-constraint 'wanted', nuking the 'gbls' at each stage</span>
<a name="line-3"></a><span class='hs-comment'>-- It's conservative in that if the seed could *possibly*</span>
<a name="line-4"></a><span class='hs-comment'>-- grow to include a type variable, then it does</span>
<a name="line-5"></a>
<a name="line-6"></a><a name="growWanteds"></a><span class='hs-definition'>growWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span>
<a name="line-7"></a><span class='hs-definition'>growWanteds</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fixVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>growWC</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-8"></a>
<a name="line-9"></a><a name="growWantedEVs"></a><span class='hs-definition'>growWantedEVs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span>
<a name="line-10"></a><span class='hs-definition'>growWantedEVs</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>ws</span> <span class='hs-varid'>tvs</span>
<a name="line-11"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>ws</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-12"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fixVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>growPreds</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ws</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs</span>
<a name="line-13"></a>
<a name="line-14"></a><a name="growWC"></a><span class='hs-comment'>--------  Helper functions, do not do fixpoint ------------------------</span>
<a name="line-15"></a><span class='hs-definition'>growWC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span>
<a name="line-16"></a><span class='hs-definition'>growWC</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growImplics</span> <span class='hs-varid'>gbl_tvs</span>             <span class='hs-layout'>(</span><span class='hs-varid'>wc_impl</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span>
<a name="line-17"></a>                    <span class='hs-varid'>growPreds</span>   <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>ctPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span>
<a name="line-18"></a>                    <span class='hs-varid'>growPreds</span>   <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>ctPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_insol</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-19"></a>
<a name="line-20"></a><a name="growImplics"></a><span class='hs-definition'>growImplics</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span>
<a name="line-21"></a><span class='hs-definition'>growImplics</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>implics</span> <span class='hs-varid'>tvs</span>
<a name="line-22"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-varid'>grow_implic</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>implics</span>
<a name="line-23"></a>  <span class='hs-keyword'>where</span>
<a name="line-24"></a>    <span class='hs-varid'>grow_implic</span> <span class='hs-varid'>implic</span> <span class='hs-varid'>tvs</span>
<a name="line-25"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>grow</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>ic_skols</span> <span class='hs-varid'>implic</span>
<a name="line-26"></a>      <span class='hs-keyword'>where</span>
<a name="line-27"></a>        <span class='hs-varid'>grow</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growWC</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_wanted</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span>
<a name="line-28"></a>               <span class='hs-varid'>growPreds</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>evVarPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_given</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-29"></a>               <span class='hs-comment'>-- We must grow from givens too; see test IPRun</span>
<a name="line-30"></a>
<a name="line-31"></a><a name="growPreds"></a><span class='hs-definition'>growPreds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span>
<a name="line-32"></a><span class='hs-definition'>growPreds</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>get_pred</span> <span class='hs-varid'>items</span> <span class='hs-varid'>tvs</span>
<a name="line-33"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-varid'>extend</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>items</span>
<a name="line-34"></a>  <span class='hs-keyword'>where</span>
<a name="line-35"></a>    <span class='hs-varid'>extend</span> <span class='hs-varid'>item</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>`unionVarSet`</span>
<a name="line-36"></a>                      <span class='hs-layout'>(</span><span class='hs-varid'>growPredTyVars</span> <span class='hs-layout'>(</span><span class='hs-varid'>get_pred</span> <span class='hs-varid'>item</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>gbl_tvs</span><span class='hs-layout'>)</span>
<a name="line-37"></a>
<a name="line-38"></a><a name="quantifyMe"></a><span class='hs-comment'>--------------------</span>
<a name="line-39"></a><span class='hs-definition'>quantifyMe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span>      <span class='hs-comment'>-- Quantifying over these</span>
<a name="line-40"></a>	   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span>
<a name="line-41"></a>	   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>	    <span class='hs-comment'>-- True &lt;=&gt; quantify over this wanted</span>
<a name="line-42"></a><span class='hs-definition'>quantifyMe</span> <span class='hs-varid'>qtvs</span> <span class='hs-varid'>ct</span>
<a name="line-43"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isIPPred</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- Note [Inheriting implicit parameters]</span>
<a name="line-44"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>	  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>pred</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>qtvs</span>
<a name="line-45"></a>  <span class='hs-keyword'>where</span>
<a name="line-46"></a>    <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span>
</pre>\end{code}

Note [Avoid unecessary constraint simplification]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When inferring the type of a let-binding, with simplifyInfer,
try to avoid unnecessariliy simplifying class constraints.
Doing so aids sharing, but it also helps with delicate 
situations like
   instance C t => C [t] where ..
   f :: C [t] => ....
   f x = let g y = ...(constraint C [t])... 
         in ...
When inferring a type for 'g', we don't want to apply the
instance decl, because then we can't satisfy (C t).  So we
just notice that g isn't quantified over 't' and partition
the contraints before simplifying.

This only half-works, but then let-generalisation only half-works.


Note [Inheriting implicit parameters]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this:

	f x = (x::Int) + ?y

where f is *not* a top-level binding.
From the RHS of f we'll get the constraint (?y::Int).
There are two types we might infer for f:

	f :: Int -> Int

(so we get ?y from the context of f's definition), or

	f :: (?y::Int) => Int -> Int

At first you might think the first was better, becuase then
?y behaves like a free variable of the definition, rather than
having to be passed at each call site.  But of course, the WHOLE
IDEA is that ?y should be passed at each call site (that's what
dynamic binding means) so we'd better infer the second.

BOTTOM LINE: when *inferring types* you *must* quantify 
over implicit parameters. See the predicate isFreeWhenInferring.


*********************************************************************************
*                                                                                 * 
*                             RULES                                               *
*                                                                                 *
***********************************************************************************

Note [Simplifying RULE lhs constraints]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
On the LHS of transformation rules we only simplify only equalities,
but not dictionaries.  We want to keep dictionaries unsimplified, to
serve as the available stuff for the RHS of the rule.  We *do* want to
simplify equalities, however, to detect ill-typed rules that cannot be
applied.

Implementation: the TcSFlags carried by the TcSMonad controls the
amount of simplification, so simplifyRuleLhs just sets the flag
appropriately.

Example.  Consider the following left-hand side of a rule
	f (x == y) (y > z) = ...
If we typecheck this expression we get constraints
	d1 :: Ord a, d2 :: Eq a
We do NOT want to "simplify" to the LHS
	forall x::a, y::a, z::a, d1::Ord a.
	  f ((==) (eqFromOrd d1) x y) ((>) d1 y z) = ...
Instead we want	
	forall x::a, y::a, z::a, d1::Ord a, d2::Eq a.
	  f ((==) d2 x y) ((>) d1 y z) = ...

Here is another example:
	fromIntegral :: (Integral a, Num b) => a -> b
	{-# RULES "foo"  fromIntegral = id :: Int -> Int #-}
In the rule, a=b=Int, and Num Int is a superclass of Integral Int. But
we *dont* want to get
	forall dIntegralInt.
	   fromIntegral Int Int dIntegralInt (scsel dIntegralInt) = id Int
because the scsel will mess up RULE matching.  Instead we want
	forall dIntegralInt, dNumInt.
	  fromIntegral Int Int dIntegralInt dNumInt = id Int

Even if we have 
	g (x == y) (y == z) = ..
where the two dictionaries are *identical*, we do NOT WANT
	forall x::a, y::a, z::a, d1::Eq a
	  f ((==) d1 x y) ((>) d1 y z) = ...
because that will only match if the dict args are (visibly) equal.
Instead we want to quantify over the dictionaries separately.

In short, simplifyRuleLhs must *only* squash equalities, leaving
all dicts unchanged, with absolutely no sharing.  

HOWEVER, under a nested implication things are different
Consider
  f :: (forall a. Eq a => a->a) -> Bool -> ...
  {-# RULES "foo" forall (v::forall b. Eq b => b->b).
       f b True = ...
    #=}
Here we *must* solve the wanted (Eq a) from the given (Eq a)
resulting from skolemising the agument type of g.  So we 
revert to SimplCheck when going under an implication.  

\begin{code}
<pre><a name="line-1"></a><a name="simplifyRule"></a><span class='hs-definition'>simplifyRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleName</span> 
<a name="line-2"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span>		<span class='hs-comment'>-- Explicit skolems</span>
<a name="line-3"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>	<span class='hs-comment'>-- Constraints from LHS</span>
<a name="line-4"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>	<span class='hs-comment'>-- Constraints from RHS</span>
<a name="line-5"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> 		<span class='hs-comment'>-- LHS dicts</span>
<a name="line-6"></a>                     <span class='hs-conid'>TcEvBinds</span><span class='hs-layout'>,</span>		<span class='hs-comment'>-- Evidence for LHS</span>
<a name="line-7"></a>                     <span class='hs-conid'>TcEvBinds</span><span class='hs-layout'>)</span>		<span class='hs-comment'>-- Evidence for RHS</span>
<a name="line-8"></a><span class='hs-comment'>-- See Note [Simplifying RULE lhs constraints]</span>
<a name="line-9"></a><span class='hs-definition'>simplifyRule</span> <span class='hs-varid'>name</span> <span class='hs-varid'>tv_bndrs</span> <span class='hs-varid'>lhs_wanted</span> <span class='hs-varid'>rhs_wanted</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>loc</span>        <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getCtLoc</span> <span class='hs-layout'>(</span><span class='hs-conid'>RuleSkol</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_lhs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>lhs_wanted</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUntouchables</span>
<a name="line-13"></a>	     	 <span class='hs-comment'>-- We allow ourselves to unify environment </span>
<a name="line-14"></a>		 <span class='hs-comment'>-- variables; hence *no untouchables*</span>
<a name="line-15"></a>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>lhs_results</span><span class='hs-layout'>,</span> <span class='hs-varid'>lhs_binds</span><span class='hs-layout'>)</span>
<a name="line-17"></a>              <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplRuleLhs</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>zonked_lhs</span>
<a name="line-18"></a>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyRule"</span> <span class='hs-varop'>$</span>
<a name="line-20"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"zonked_lhs"</span>   <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_lhs</span> 
<a name="line-21"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"lhs_results"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>lhs_results</span>
<a name="line-22"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"lhs_binds"</span>    <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>lhs_binds</span> 
<a name="line-23"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"rhs_wanted"</span>   <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_wanted</span> <span class='hs-keyglyph'>]</span>
<a name="line-24"></a>
<a name="line-25"></a>
<a name="line-26"></a>       <span class='hs-comment'>-- Don't quantify over equalities (judgement call here)</span>
<a name="line-27"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>dicts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEqPred</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ctPred</span><span class='hs-layout'>)</span>
<a name="line-28"></a>                                         <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>lhs_results</span><span class='hs-layout'>)</span>
<a name="line-29"></a>             <span class='hs-varid'>lhs_dicts</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>cc_id</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>dicts</span><span class='hs-layout'>)</span>
<a name="line-30"></a>                                 <span class='hs-comment'>-- Dicts and implicit parameters</span>
<a name="line-31"></a>
<a name="line-32"></a>           <span class='hs-comment'>-- Fail if we have not got down to unsolved flats</span>
<a name="line-33"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-34"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitImplication</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_untch</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>untch</span>
<a name="line-35"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ic_env</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyNameEnv</span>
<a name="line-36"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>tv_bndrs</span>
<a name="line-37"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lhs_dicts</span>
<a name="line-38"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lhs_results</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqs</span> <span class='hs-layout'>}</span>
<a name="line-39"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>lhs_results</span>
<a name="line-40"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-41"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ic_loc</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span>
<a name="line-42"></a>
<a name="line-43"></a>	     <span class='hs-comment'>-- Notice that we simplify the RHS with only the explicitly</span>
<a name="line-44"></a>	     <span class='hs-comment'>-- introduced skolems, allowing the RHS to constrain any </span>
<a name="line-45"></a>	     <span class='hs-comment'>-- unification variables.</span>
<a name="line-46"></a>	     <span class='hs-comment'>-- Then, and only then, we call zonkQuantifiedTypeVariables</span>
<a name="line-47"></a>	     <span class='hs-comment'>-- Example   foo :: Ord a =&gt; a -&gt; a</span>
<a name="line-48"></a>	     <span class='hs-comment'>--		  foo_spec :: Int -&gt; Int</span>
<a name="line-49"></a>	     <span class='hs-comment'>--		  {-# RULE "foo"  foo = foo_spec #-}</span>
<a name="line-50"></a>	     <span class='hs-comment'>--	    Here, it's the RHS that fixes the type variable</span>
<a name="line-51"></a>
<a name="line-52"></a>	     <span class='hs-comment'>-- So we don't want to make untouchable the type</span>
<a name="line-53"></a>	     <span class='hs-comment'>-- variables in the envt of the RHS, because they include</span>
<a name="line-54"></a>	     <span class='hs-comment'>-- the template variables of the RULE</span>
<a name="line-55"></a>
<a name="line-56"></a>	     <span class='hs-comment'>-- Hence the rather painful ad-hoc treatement here</span>
<a name="line-57"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rhs_binds_var</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>EvBindsVar</span> <span class='hs-varid'>evb_ref</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-58"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"rhs of rule"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>doubleQuotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ftext</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-59"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rhs_binds1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplifyCheck</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplCheck</span> <span class='hs-varid'>doc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-60"></a>            <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span>
<a name="line-61"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span>
<a name="line-62"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitBag</span> <span class='hs-varop'>$</span>
<a name="line-63"></a>                    <span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_untch</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUntouchables</span>
<a name="line-64"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_env</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyNameEnv</span>
<a name="line-65"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>tv_bndrs</span>
<a name="line-66"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lhs_dicts</span>
<a name="line-67"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_wanted</span>
<a name="line-68"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>rhs_wanted</span>
<a name="line-69"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_binds_var</span>
<a name="line-70"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_loc</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-71"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rhs_binds2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readTcRef</span> <span class='hs-varid'>evb_ref</span>
<a name="line-72"></a>
<a name="line-73"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>lhs_dicts</span>
<a name="line-74"></a>                <span class='hs-layout'>,</span> <span class='hs-conid'>EvBinds</span> <span class='hs-varid'>lhs_binds</span> 
<a name="line-75"></a>                <span class='hs-layout'>,</span> <span class='hs-conid'>EvBinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_binds1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>rhs_binds2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}


*********************************************************************************
*                                                                                 * 
*                                 Main Simplifier                                 *
*                                                                                 *
***********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="simplifyCheck"></a><span class='hs-definition'>simplifyCheck</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplContext</span>
<a name="line-2"></a>	      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>	<span class='hs-comment'>-- Wanted</span>
<a name="line-3"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-4"></a><span class='hs-comment'>-- Solve a single, top-level implication constraint</span>
<a name="line-5"></a><span class='hs-comment'>-- e.g. typically one created from a top-level type signature</span>
<a name="line-6"></a><span class='hs-comment'>-- 	    f :: forall a. [a] -&gt; [a]</span>
<a name="line-7"></a><span class='hs-comment'>--          f x = rhs</span>
<a name="line-8"></a><span class='hs-comment'>-- We do this even if the function has no polymorphism:</span>
<a name="line-9"></a><span class='hs-comment'>--    	    g :: Int -&gt; Int</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-comment'>--          g y = rhs</span>
<a name="line-12"></a><span class='hs-comment'>-- (whereas for *nested* bindings we would not create</span>
<a name="line-13"></a><span class='hs-comment'>--  an implication constraint for g at all.)</span>
<a name="line-14"></a><span class='hs-comment'>--</span>
<a name="line-15"></a><span class='hs-comment'>-- Fails if can't solve something in the input wanteds</span>
<a name="line-16"></a><span class='hs-definition'>simplifyCheck</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>wanteds</span>
<a name="line-17"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wanteds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-18"></a>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyCheck {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span>
<a name="line-20"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"wanted ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-21"></a>
<a name="line-22"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsolved</span><span class='hs-layout'>,</span> <span class='hs-varid'>ev_binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> 
<a name="line-23"></a>           <span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>ctxt</span> <span class='hs-conid'>NoUntouchables</span> <span class='hs-varid'>wanteds</span>
<a name="line-24"></a>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyCheck }"</span> <span class='hs-varop'>$</span>
<a name="line-26"></a>         <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"unsolved ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved</span>
<a name="line-27"></a>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>unsolved</span>
<a name="line-29"></a>
<a name="line-30"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>ev_binds</span> <span class='hs-layout'>}</span>
<a name="line-31"></a>
<a name="line-32"></a><a name="solveWanteds"></a><span class='hs-comment'>----------------</span>
<a name="line-33"></a><span class='hs-definition'>solveWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplContext</span> 
<a name="line-34"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Untouchables</span>
<a name="line-35"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-36"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-comment'>-- Returns: residual constraints, plus evidence bindings </span>
<a name="line-38"></a><span class='hs-comment'>-- NB: When we are called from TcM there are no inerts to pass down to TcS</span>
<a name="line-39"></a><span class='hs-definition'>solveWanteds</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>wanted</span>
<a name="line-40"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>ev_binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcS</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>emptyInert</span> <span class='hs-varid'>emptyWorkList</span> <span class='hs-varop'>$</span>
<a name="line-41"></a>                               <span class='hs-varid'>solve_wanteds</span> <span class='hs-varid'>wanted</span>
<a name="line-42"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wc_ret</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wc_out</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>keepWanted</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>wc_out</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> 
<a name="line-43"></a>                      <span class='hs-comment'>-- Discard Derived</span>
<a name="line-44"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_ret</span><span class='hs-layout'>,</span> <span class='hs-varid'>ev_binds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-45"></a>
<a name="line-46"></a><a name="solve_wanteds"></a><span class='hs-definition'>solve_wanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-47"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>  <span class='hs-comment'>-- NB: wc_flats may be wanted *or* derived now</span>
<a name="line-48"></a><span class='hs-definition'>solve_wanteds</span> <span class='hs-varid'>wanted</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flats</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> 
<a name="line-49"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-50"></a>
<a name="line-51"></a>                 <span class='hs-comment'>-- Try the flat bit</span>
<a name="line-52"></a>                 <span class='hs-comment'>-- Discard from insols all the derived/given constraints</span>
<a name="line-53"></a>                 <span class='hs-comment'>-- because they will show up again when we try to solve</span>
<a name="line-54"></a>                 <span class='hs-comment'>-- everything else.  Solving them a second time is a bit</span>
<a name="line-55"></a>                 <span class='hs-comment'>-- of a waste, but the code is simple, and the program is</span>
<a name="line-56"></a>                 <span class='hs-comment'>-- wrong anyway!</span>
<a name="line-57"></a>
<a name="line-58"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_flats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flats</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>keepWanted</span> <span class='hs-varid'>insols</span>
<a name="line-59"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-varop'>$</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>all_flats</span>
<a name="line-60"></a>
<a name="line-61"></a>       <span class='hs-comment'>-- solve_wanteds iterates when it is able to float equalities </span>
<a name="line-62"></a>       <span class='hs-comment'>-- out of one or more of the implications. </span>
<a name="line-63"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simpl_loop</span> <span class='hs-num'>1</span> <span class='hs-varid'>implics</span>
<a name="line-64"></a>
<a name="line-65"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>insoluble_flats</span><span class='hs-layout'>,</span><span class='hs-varid'>unsolved_flats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>extractUnsolvedTcS</span> 
<a name="line-66"></a>
<a name="line-67"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>bb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcEvBindsMap</span>
<a name="line-68"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSTyBindsMap</span>
<a name="line-69"></a>
<a name="line-70"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds }"</span> <span class='hs-varop'>$</span>
<a name="line-71"></a>                 <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_flats   ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-72"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-73"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"current evbinds  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>bb</span><span class='hs-layout'>)</span>
<a name="line-74"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"current tybinds  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>varEnvElts</span> <span class='hs-varid'>tb</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-75"></a>                      <span class='hs-keyglyph'>]</span>
<a name="line-76"></a>
<a name="line-77"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>remaining_unsolved_flats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveCTyFunEqs</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-78"></a>                <span class='hs-comment'>-- See Note [Solving Family Equations]</span>
<a name="line-79"></a>                <span class='hs-comment'>-- NB: remaining_flats has already had subst applied</span>
<a name="line-80"></a>
<a name="line-81"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-82"></a>         <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>substCt</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-varid'>remaining_unsolved_flats</span>
<a name="line-83"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>substImplication</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-84"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>substCt</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-varid'>insoluble_flats</span> <span class='hs-layout'>}</span>
<a name="line-85"></a>       <span class='hs-layout'>}</span>
<a name="line-86"></a>
<a name="line-87"></a><a name="simpl_loop"></a><span class='hs-definition'>simpl_loop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-88"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span>
<a name="line-89"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-90"></a><span class='hs-definition'>simpl_loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>implics</span>
<a name="line-91"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>10</span> 
<a name="line-92"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: loop!"</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>implics</span>
<a name="line-93"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> 
<a name="line-94"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>implic_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveNestedImplications</span> <span class='hs-varid'>implics</span>
<a name="line-95"></a>
<a name="line-96"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-97"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>unsolved_flats</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extractUnsolved</span> <span class='hs-varid'>inerts</span>
<a name="line-98"></a>
<a name="line-99"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ecache_pre</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSEvVarCacheMap</span>
<a name="line-100"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>k</span> <span class='hs-varid'>z</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>foldTM</span> <span class='hs-varid'>k</span> <span class='hs-varid'>m</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>ecache_pre</span><span class='hs-layout'>)</span>
<a name="line-101"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"ecache_pre"</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>pr</span>
<a name="line-102"></a>
<a name="line-103"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>improve_eqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implic_eqs</span><span class='hs-layout'>)</span>
<a name="line-104"></a>                        <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>implic_eqs</span>
<a name="line-105"></a>                        <span class='hs-keyword'>else</span> <span class='hs-varid'>applyDefaultingRules</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-106"></a>
<a name="line-107"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ecache_post</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSEvVarCacheMap</span>
<a name="line-108"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>po</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>k</span> <span class='hs-varid'>z</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>foldTM</span> <span class='hs-varid'>k</span> <span class='hs-varid'>m</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>ecache_post</span><span class='hs-layout'>)</span>
<a name="line-109"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"ecache_po"</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>po</span>
<a name="line-110"></a>
<a name="line-111"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: simpl_loop end"</span> <span class='hs-varop'>$</span>
<a name="line-112"></a>             <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"improve_eqs      ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>improve_eqs</span>
<a name="line-113"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_flats   ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-114"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>]</span>
<a name="line-115"></a>
<a name="line-116"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>improve_eqs</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>unsolved_implics</span> 
<a name="line-117"></a>         <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-varop'>$</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>improve_eqs</span>
<a name="line-118"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>simpl_loop</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-119"></a>
<a name="line-120"></a><a name="solveNestedImplications"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span>
<a name="line-121"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-122"></a><span class='hs-comment'>-- Precondition: the TcS inerts may contain unsolved flats which have </span>
<a name="line-123"></a><span class='hs-comment'>-- to be converted to givens before we go inside a nested implication.</span>
<a name="line-124"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-varid'>implics</span>
<a name="line-125"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics</span>
<a name="line-126"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span>
<a name="line-127"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> 
<a name="line-128"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-129"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-sel'>_insoluble_flats</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_flats</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span><span class='hs-varid'>thinner_inerts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extractUnsolved</span> <span class='hs-varid'>inerts</span> 
<a name="line-130"></a>
<a name="line-131"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>implic_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span>
<a name="line-132"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>doWithInert</span> <span class='hs-varid'>thinner_inerts</span> <span class='hs-varop'>$</span> 
<a name="line-133"></a>              <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pushed_givens</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>givens_from_wanteds</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-134"></a>                       <span class='hs-varid'>tcs_untouchables</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterVarSet</span> <span class='hs-varid'>isFlexiTcsTv</span> <span class='hs-varop'>$</span> 
<a name="line-135"></a>                                          <span class='hs-varid'>tyVarsOfCts</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-136"></a>                 <span class='hs-comment'>-- See Note [Preparing inert set for implications]</span>
<a name="line-137"></a>	         <span class='hs-comment'>-- Push the unsolved wanteds inwards, but as givens</span>
<a name="line-138"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: preparing inerts for implications {"</span> <span class='hs-varop'>$</span> 
<a name="line-139"></a>                   <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tcs_untouchables</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pushed_givens</span><span class='hs-keyglyph'>]</span>
<a name="line-140"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-varid'>pushed_givens</span> 
<a name="line-141"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: } now doing nested implications {"</span> <span class='hs-varid'>empty</span>
<a name="line-142"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>flatMapBagPairM</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveImplication</span> <span class='hs-varid'>tcs_untouchables</span><span class='hs-layout'>)</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span>
<a name="line-143"></a>
<a name="line-144"></a>       <span class='hs-comment'>-- ... and we are back in the original TcS inerts </span>
<a name="line-145"></a>       <span class='hs-comment'>-- Notice that the original includes the _insoluble_flats so it was safe to ignore</span>
<a name="line-146"></a>       <span class='hs-comment'>-- them in the beginning of this function.</span>
<a name="line-147"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: done nested implications }"</span> <span class='hs-varop'>$</span>
<a name="line-148"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"implic_eqs ="</span>       <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>implic_eqs</span>
<a name="line-149"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>]</span>
<a name="line-150"></a>
<a name="line-151"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>implic_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-152"></a>
<a name="line-153"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>givens_from_wanteds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-varid'>get_wanted</span> <span class='hs-conid'>[]</span>
<a name="line-154"></a>        <span class='hs-varid'>get_wanted</span> <span class='hs-varid'>cc</span> <span class='hs-varid'>rest_givens</span>
<a name="line-155"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>pushable_wanted</span> <span class='hs-varid'>cc</span>
<a name="line-156"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>this_given</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGivenFlavor</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_flavor</span> <span class='hs-varid'>cc</span><span class='hs-layout'>)</span> <span class='hs-conid'>UnkSkol</span> <span class='hs-layout'>}</span>
<a name="line-157"></a>              <span class='hs-keyword'>in</span> <span class='hs-varid'>this_given</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rest_givens</span>
<a name="line-158"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rest_givens</span> 
<a name="line-159"></a>
<a name="line-160"></a>        <span class='hs-varid'>pushable_wanted</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> 
<a name="line-161"></a>        <span class='hs-varid'>pushable_wanted</span> <span class='hs-varid'>cc</span> 
<a name="line-162"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isWantedCt</span> <span class='hs-varid'>cc</span> 
<a name="line-163"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isEqPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>cc</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- see Note [Preparing inert set for implications]</span>
<a name="line-164"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> 
<a name="line-165"></a>
<a name="line-166"></a><a name="solveImplication"></a><span class='hs-definition'>solveImplication</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span>     <span class='hs-comment'>-- Untouchable TcS unification variables</span>
<a name="line-167"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Implication</span>    <span class='hs-comment'>-- Wanted</span>
<a name="line-168"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- All wanted or derived floated equalities: var = type</span>
<a name="line-169"></a>                         <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Unsolved rest (always empty or singleton)</span>
<a name="line-170"></a><span class='hs-comment'>-- Precondition: The TcS monad contains an empty worklist and given-only inerts </span>
<a name="line-171"></a><span class='hs-comment'>-- which after trying to solve this implication we must restore to their original value</span>
<a name="line-172"></a><span class='hs-definition'>solveImplication</span> <span class='hs-varid'>tcs_untouchables</span>
<a name="line-173"></a>     <span class='hs-varid'>imp</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_untch</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>untch</span>
<a name="line-174"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds</span>
<a name="line-175"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skols</span> 
<a name="line-176"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>givens</span>
<a name="line-177"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanteds</span>
<a name="line-178"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_loc</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-179"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nestImplicTcS</span> <span class='hs-varid'>ev_binds</span> <span class='hs-layout'>(</span><span class='hs-varid'>untch</span><span class='hs-layout'>,</span> <span class='hs-varid'>tcs_untouchables</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-180"></a>    <span class='hs-varid'>recoverTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-181"></a>       <span class='hs-comment'>-- Recover from nested failures.  Even the top level is</span>
<a name="line-182"></a>       <span class='hs-comment'>-- just a bunch of implications, so failing at the first one is bad</span>
<a name="line-183"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span> 
<a name="line-184"></a>
<a name="line-185"></a>         <span class='hs-comment'>-- Solve flat givens</span>
<a name="line-186"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solveInteractGiven</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>givens</span> 
<a name="line-187"></a>
<a name="line-188"></a>         <span class='hs-comment'>-- Simplify the wanteds</span>
<a name="line-189"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-190"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-191"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solve_wanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-192"></a>
<a name="line-193"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>res_flat_free</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_flat_bound</span><span class='hs-layout'>)</span>
<a name="line-194"></a>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floatEqualities</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>givens</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-195"></a>             <span class='hs-varid'>final_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>keepWanted</span> <span class='hs-varid'>res_flat_bound</span>
<a name="line-196"></a>
<a name="line-197"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>res_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>final_flat</span>
<a name="line-198"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-199"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span> <span class='hs-layout'>}</span>
<a name="line-200"></a>
<a name="line-201"></a>             <span class='hs-varid'>res_implic</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitImplication</span> <span class='hs-varop'>$</span>
<a name="line-202"></a>                          <span class='hs-varid'>imp</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res_wanted</span>
<a name="line-203"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>res_wanted</span> <span class='hs-layout'>}</span>
<a name="line-204"></a>
<a name="line-205"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>evbinds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcEvBindsMap</span>
<a name="line-206"></a>
<a name="line-207"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication end }"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-208"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"res_flat_free ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res_flat_free</span>
<a name="line-209"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"implication evbinds = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>evbinds</span><span class='hs-layout'>)</span>
<a name="line-210"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"res_implic ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res_implic</span> <span class='hs-keyglyph'>]</span>
<a name="line-211"></a>
<a name="line-212"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>res_flat_free</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_implic</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-213"></a>    <span class='hs-comment'>-- and we are back to the original inerts</span>
<a name="line-214"></a>
<a name="line-215"></a>
<a name="line-216"></a><a name="floatEqualities"></a><span class='hs-definition'>floatEqualities</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cts</span><span class='hs-layout'>)</span>
<a name="line-217"></a><span class='hs-comment'>-- Post: The returned FlavoredEvVar's are only Wanted or Derived</span>
<a name="line-218"></a><span class='hs-comment'>-- and come from the input wanted ev vars or deriveds </span>
<a name="line-219"></a><span class='hs-definition'>floatEqualities</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>can_given</span> <span class='hs-varid'>wantders</span>
<a name="line-220"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>hasEqualities</span> <span class='hs-varid'>can_given</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>wantders</span><span class='hs-layout'>)</span>
<a name="line-221"></a>          <span class='hs-comment'>-- Note [Float Equalities out of Implications]</span>
<a name="line-222"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>wantders</span>
<a name="line-223"></a>  
<a name="line-224"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>is_floatable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-225"></a>        <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>ct</span>
<a name="line-226"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ct_predty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span>
<a name="line-227"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>isEqPred</span> <span class='hs-varid'>ct_predty</span>
<a name="line-228"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skols</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>ct_predty</span>
<a name="line-229"></a>        <span class='hs-varid'>is_floatable</span> <span class='hs-sel'>_ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-230"></a>
<a name="line-231"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span>
<a name="line-232"></a>        <span class='hs-comment'>-- ^ NB: for type synonyms tvs_under_fsks does /not/ expand the synonym</span>
<a name="line-233"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>     
<a name="line-234"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTcTyVar</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitVarSet</span> <span class='hs-varid'>tv</span>
<a name="line-235"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FlatSkol</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcTyVarDetails</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>ty</span>
<a name="line-236"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitVarSet</span> <span class='hs-varid'>tv</span>
<a name="line-237"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unionVarSets</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-238"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>res</span>
<a name="line-239"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>arg</span>
<a name="line-240"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- The kind of a coercion binder </span>
<a name="line-241"></a>        	     	       	        <span class='hs-comment'>-- can mention type variables!</span>
<a name="line-242"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>tv</span>		      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inner_tvs</span> <span class='hs-varop'>`delVarSet`</span> <span class='hs-varid'>tv</span>
<a name="line-243"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>{- Coercion -}</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- ASSERT( not (tv `elemVarSet` inner_tvs) )</span>
<a name="line-244"></a>                                        <span class='hs-varid'>inner_tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-245"></a>          <span class='hs-keyword'>where</span>
<a name="line-246"></a>            <span class='hs-varid'>inner_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>ty</span>
</pre>\end{code}

Note [Preparing inert set for implications]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Before solving the nested implications, we convert any unsolved flat wanteds
to givens, and add them to the inert set.  Reasons:

  a) In checking mode, suppresses unnecessary errors.  We already have
     on unsolved-wanted error; adding it to the givens prevents any 
     consequential errors from showing up

  b) More importantly, in inference mode, we are going to quantify over this
     constraint, and we *don't* want to quantify over any constraints that
     are deducible from it.

  c) Flattened type-family equalities must be exposed to the nested
     constraints.  Consider
	F b ~ alpha, (forall c.  F b ~ alpha)
     Obviously this is soluble with [alpha := F b].  But the
     unification is only done by solveCTyFunEqs, right at the end of
     solveWanteds, and if we aren't careful we'll end up with an
     unsolved goal inside the implication.  We need to "push" the
     as-yes-unsolved (F b ~ alpha) inwards, as a *given*, so that it
     can be used to solve the inner (F b
     ~ alpha).  See Trac #4935.

  d) There are other cases where interactions between wanteds that can help
     to solve a constraint. For example

  	class C a b | a -> b

  	(C Int alpha), (forall d. C d blah => C Int a)

     If we push the (C Int alpha) inwards, as a given, it can produce
     a fundep (alpha~a) and this can float out again and be used to
     fix alpha.  (In general we can't float class constraints out just
     in case (C d blah) might help to solve (C Int a).)

The unsolved wanteds are *canonical* but they may not be *inert*,
because when made into a given they might interact with other givens.
Hence the call to solveInteract.  Example:

 Original inert set = (d :_g D a) /\ (co :_w  a ~ [beta]) 

We were not able to solve (a ~w [beta]) but we can't just assume it as
given because the resulting set is not inert. Hence we have to do a
'solveInteract' step first. 

Finally, note that we convert them to [Given] and NOT [Given/Solved].
The reason is that Given/Solved are weaker than Givens and may be discarded.
As an example consider the inference case, where we may have, the following 
original constraints: 
     [Wanted] F Int ~ Int
             (F Int ~ a => F Int ~ a)
If we convert F Int ~ Int to [Given/Solved] instead of Given, then the next 
given (F Int ~ a) is going to cause the Given/Solved to be ignored, casting 
the (F Int ~ a) insoluble. Hence we should really convert the residual 
wanteds to plain old Given. 

We need only push in unsolved equalities both in checking mode and inference mode: 

  (1) In checking mode we should not push given dictionaries in because of
example LongWayOverlapping.hs, where we might get strange overlap
errors between far-away constraints in the program.  But even in
checking mode, we must still push type family equations. Consider:

   type instance F True a b = a 
   type instance F False a b = b

   [w] F c a b ~ gamma 
   (c ~ True) => a ~ gamma 
   (c ~ False) => b ~ gamma

Since solveCTyFunEqs happens at the very end of solving, the only way to solve
the two implications is temporarily consider (F c a b ~ gamma) as Given (NB: not 
merely Given/Solved because it has to interact with the top-level instance 
environment) and push it inside the implications. Now, when we come out again at
the end, having solved the implications solveCTyFunEqs will solve this equality.

  (2) In inference mode, we recheck the final constraint in checking mode and
hence we will be able to solve inner implications from top-level quantified
constraints nonetheless.


Note [Extra TcsTv untouchables]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Furthemore, we record the inert set simplifier-generated unification
variables of the TcsTv kind (such as variables from instance that have
been applied, or unification flattens). These variables must be passed
to the implications as extra untouchable variables. Otherwise we have
the danger of double unifications. Example (from trac ticket #4494):

   (F Int ~ uf)  /\  (forall a. C a => F Int ~ beta) 

In this example, beta is touchable inside the implication. The first
solveInteract step leaves 'uf' ununified. Then we move inside the
implication where a new constraint
       uf  ~  beta  
emerges. We may spontaneously solve it to get uf := beta, so the whole
implication disappears but when we pop out again we are left with (F
Int ~ uf) which will be unified by our final solveCTyFunEqs stage and
uf will get unified *once more* to (F Int).

The solution is to record the TcsTvs (i.e. the simplifier-generated
unification variables) that are generated when solving the flats, and
make them untouchables for the nested implication. In the example
above uf would become untouchable, so beta would be forced to be
unified as beta := uf.

NB: A consequence is that every simplifier-generated TcsTv variable
    that gets floated out of an implication becomes now untouchable
    next time we go inside that implication to solve any residual
    constraints. In effect, by floating an equality out of the
    implication we are committing to have it solved in the outside.

Note [Float Equalities out of Implications]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
We want to float equalities out of vanilla existentials, but *not* out 
of GADT pattern matches. 


\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><a name="solveCTyFunEqs"></a><span class='hs-definition'>solveCTyFunEqs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>TvSubst</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cts</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-comment'>-- Default equalities (F xi ~ alpha) by setting (alpha := F xi), whenever possible</span>
<a name="line-4"></a><span class='hs-comment'>-- See Note [Solving Family Equations]</span>
<a name="line-5"></a><span class='hs-comment'>-- Returns: a bunch of unsolved constraints from the original Cts and implications</span>
<a name="line-6"></a><span class='hs-comment'>--          where the newly generated equalities (alpha := F xi) have been substituted through.</span>
<a name="line-7"></a><span class='hs-definition'>solveCTyFunEqs</span> <span class='hs-varid'>cts</span>
<a name="line-8"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>untch</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUntouchables</span> 
<a name="line-9"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsolved_can_cts</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ni_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>cv_binds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-10"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSolvableCTyFunEqs</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>cts</span>
<a name="line-11"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"defaultCTyFunEqs"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"Trying to default family equations:"</span>
<a name="line-12"></a>                                          <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ni_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cv_binds</span>
<a name="line-13"></a>                                          <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-14"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>solve_one</span> <span class='hs-varid'>cv_binds</span>
<a name="line-15"></a>
<a name="line-16"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>niFixTvSubst</span> <span class='hs-varid'>ni_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_can_cts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-17"></a>  <span class='hs-keyword'>where</span>
<a name="line-18"></a>    <span class='hs-varid'>solve_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>cv</span><span class='hs-layout'>,</span><span class='hs-varid'>tv</span><span class='hs-layout'>,</span><span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span>
<a name="line-19"></a>                              <span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEqBind</span> <span class='hs-varid'>cv</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-20"></a>                                       <span class='hs-layout'>(</span><span class='hs-conid'>Wanted</span> <span class='hs-varop'>$</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"Met an already solved function equality!"</span><span class='hs-layout'>)</span>
<a name="line-21"></a>                              <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-comment'>-- Don't care about flavors etc this is</span>
<a name="line-22"></a>                                          <span class='hs-comment'>-- the last thing happening</span>
<a name="line-23"></a>                              <span class='hs-layout'>}</span>
<a name="line-24"></a>
<a name="line-25"></a><a name="FunEqBinds"></a><span class='hs-comment'>------------</span>
<a name="line-26"></a><a name="FunEqBinds"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>FunEqBinds</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>TvSubstEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>CoVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-27"></a>  <span class='hs-comment'>-- The TvSubstEnv is not idempotent, but is loop-free</span>
<a name="line-28"></a>  <span class='hs-comment'>-- See Note [Non-idempotent substitution] in Unify</span>
<a name="line-29"></a><a name="emptyFunEqBinds"></a><span class='hs-definition'>emptyFunEqBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FunEqBinds</span>
<a name="line-30"></a><span class='hs-definition'>emptyFunEqBinds</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyVarEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-31"></a>
<a name="line-32"></a><a name="extendFunEqBinds"></a><span class='hs-definition'>extendFunEqBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FunEqBinds</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FunEqBinds</span>
<a name="line-33"></a><span class='hs-definition'>extendFunEqBinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>cv_binds</span><span class='hs-layout'>)</span> <span class='hs-varid'>cv</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span>
<a name="line-34"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendVarEnv</span> <span class='hs-varid'>tv_subst</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>cv</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>cv_binds</span><span class='hs-layout'>)</span>
<a name="line-35"></a>
<a name="line-36"></a><a name="getSolvableCTyFunEqs"></a><span class='hs-comment'>------------</span>
<a name="line-37"></a><span class='hs-definition'>getSolvableCTyFunEqs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcsUntouchables</span>
<a name="line-38"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>                <span class='hs-comment'>-- Precondition: all Wanteds or Derived!</span>
<a name="line-39"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>FunEqBinds</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Postcondition: returns the unsolvables</span>
<a name="line-40"></a><span class='hs-definition'>getSolvableCTyFunEqs</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>cts</span>
<a name="line-41"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bag</span><span class='hs-varop'>.</span><span class='hs-varid'>foldlBag</span> <span class='hs-varid'>dflt_funeq</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyCts</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyFunEqBinds</span><span class='hs-layout'>)</span> <span class='hs-varid'>cts</span>
<a name="line-42"></a>  <span class='hs-keyword'>where</span>
<a name="line-43"></a>    <span class='hs-varid'>dflt_funeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>FunEqBinds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span>
<a name="line-44"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>FunEqBinds</span><span class='hs-layout'>)</span>
<a name="line-45"></a>    <span class='hs-varid'>dflt_funeq</span> <span class='hs-layout'>(</span><span class='hs-varid'>cts_in</span><span class='hs-layout'>,</span> <span class='hs-varid'>feb</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>tv_subst</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-46"></a>               <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cv</span>
<a name="line-47"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span>
<a name="line-48"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span>
<a name="line-49"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span>
<a name="line-50"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-51"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>xi</span>      <span class='hs-comment'>-- RHS is a type variable</span>
<a name="line-52"></a>
<a name="line-53"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isTouchableMetaTyVar_InRange</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>tv</span>
<a name="line-54"></a>           <span class='hs-comment'>-- And it's a *touchable* unification variable</span>
<a name="line-55"></a>
<a name="line-56"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>xi</span> <span class='hs-varop'>`isSubKind`</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span>
<a name="line-57"></a>         <span class='hs-comment'>-- Must do a small kind check since TcCanonical invariants </span>
<a name="line-58"></a>         <span class='hs-comment'>-- on family equations only impose compatibility, not subkinding</span>
<a name="line-59"></a>
<a name="line-60"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarEnv`</span> <span class='hs-varid'>tv_subst</span><span class='hs-layout'>)</span>
<a name="line-61"></a>           <span class='hs-comment'>-- Check not in extra_binds</span>
<a name="line-62"></a>           <span class='hs-comment'>-- See Note [Solving Family Equations], Point 1</span>
<a name="line-63"></a>
<a name="line-64"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>niSubstTvSet</span> <span class='hs-varid'>tv_subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-65"></a>           <span class='hs-comment'>-- Occurs check: see Note [Solving Family Equations], Point 2</span>
<a name="line-66"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span> <span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isGivenOrSolved</span> <span class='hs-varid'>fl</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-67"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>cts_in</span><span class='hs-layout'>,</span> <span class='hs-varid'>extendFunEqBinds</span> <span class='hs-varid'>feb</span> <span class='hs-varid'>cv</span> <span class='hs-varid'>tv</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-68"></a>
<a name="line-69"></a>    <span class='hs-varid'>dflt_funeq</span> <span class='hs-layout'>(</span><span class='hs-varid'>cts_in</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_eq_binds</span><span class='hs-layout'>)</span> <span class='hs-varid'>ct</span>
<a name="line-70"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>cts_in</span> <span class='hs-varop'>`extendCts`</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_eq_binds</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Solving Family Equations] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
After we are done with simplification we may be left with constraints of the form:
     [Wanted] F xis ~ beta 
If 'beta' is a touchable unification variable not already bound in the TyBinds 
then we'd like to create a binding for it, effectively "defaulting" it to be 'F xis'.

When is it ok to do so? 
    1) 'beta' must not already be defaulted to something. Example: 

           [Wanted] F Int  ~ beta   <~ Will default [beta := F Int]
           [Wanted] F Char ~ beta   <~ Already defaulted, can't default again. We 
                                       have to report this as unsolved.

    2) However, we must still do an occurs check when defaulting (F xis ~ beta), to 
       set [beta := F xis] only if beta is not among the free variables of xis.

    3) Notice that 'beta' can't be bound in ty binds already because we rewrite RHS 
       of type family equations. See Inert Set invariants in TcInteract. 


*********************************************************************************
*                                                                               * 
*                          Defaulting and disamgiguation                        *
*                                                                               *
*********************************************************************************

Basic plan behind applyDefaulting rules: 
 
 Step 1:  
    Split wanteds into defaultable groups, `groups' and the rest `rest_wanted' 
    For each defaultable group, do: 
      For each possible substitution for [alpha |-> tau] where `alpha' is the 
      group's variable, do: 
        1) Make up new TcEvBinds
        2) Extend TcS with (groupVariable 
        3) given_inert <- solveOne inert (given : a ~ tau) 
        4) (final_inert,unsolved) <- solveWanted (given_inert) (group_constraints)
        5) if unsolved == empty then 
                 sneakyUnify a |-> tau 
                 write the evidence bins
                 return (final_inert ++ group_constraints,[]) 
                      -- will contain the info (alpha |-> tau)!!
                 goto next defaultable group 
           if unsolved <> empty then 
                 throw away evidence binds
                 try next substitution 
     If you've run out of substitutions for this group, too bad, you failed 
                 return (inert,group) 
                 goto next defaultable group
 
 Step 2: 
   Collect all the (canonical-cts, wanteds) gathered this way. 
   - Do a solveGiven over the canonical-cts to make sure they are inert 
------------------------------------------------------------------------------------------


\begin{code}
<pre><a name="line-1"></a><a name="applyDefaultingRules"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span>      <span class='hs-comment'>-- All wanteds</span>
<a name="line-2"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>  <span class='hs-comment'>-- All wanteds again!</span>
<a name="line-3"></a><span class='hs-comment'>-- Return some *extra* givens, which express the </span>
<a name="line-4"></a><span class='hs-comment'>-- type-class-default choice</span>
<a name="line-5"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-varid'>wanteds</span>
<a name="line-6"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>wanteds</span> 
<a name="line-7"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>emptyBag</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules { "</span> <span class='hs-varop'>$</span> 
<a name="line-10"></a>                  <span class='hs-varid'>text</span> <span class='hs-str'>"wanteds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>untch</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUntouchables</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tv_cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>defaultTyVar</span> <span class='hs-varid'>untch</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-13"></a>                   <span class='hs-varid'>varSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfCDicts</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-14"></a>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDefaultInfo</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>groups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findDefaultableGroups</span> <span class='hs-varid'>info</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>wanteds</span>
<a name="line-17"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"findDefaultableGroups"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"groups="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>groups</span>
<a name="line-18"></a>                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"untouchables="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span>  <span class='hs-varid'>untch</span> 
<a name="line-19"></a>                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"info="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>info</span> <span class='hs-keyglyph'>]</span>
<a name="line-20"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>deflt_cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>groups</span>
<a name="line-21"></a>
<a name="line-22"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules }"</span> <span class='hs-varop'>$</span> 
<a name="line-23"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Tyvar defaults ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tv_cts</span>
<a name="line-24"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Type defaults ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>deflt_cts</span><span class='hs-keyglyph'>]</span>
<a name="line-25"></a>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionManyBags</span> <span class='hs-varid'>deflt_cts</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>unionManyBags</span> <span class='hs-varid'>tv_cts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [tryTcS in defaulting]
~~~~~~~~~~~~~~~~~~~~~~~~~~~

defaultTyVar and disambigGroup create new evidence variables for
default equations, and hence update the EvVar cache. However, after
applyDefaultingRules we will try to solve these default equations
using solveInteractCts, which will consult the cache and solve those
EvVars from themselves! That's wrong.

To avoid this problem we guard defaulting under a @tryTcS@ which leaves
the original cache unmodified.

There is a second reason for @tryTcS@ in defaulting: disambGroup does
some constraint solving to determine if a default equation is
``useful'' in solving some wanted constraints, but we want to
discharge all evidence and unifications that may have happened during
this constraint solving.

Finally, @tryTcS@ importantly does not inherit the original cache from
the higher level but makes up a new cache, the reason is that disambigGroup
will call solveInteractCts so the new derived and the wanteds must not be 
in the cache!


\begin{code}
<pre><a name="line-1"></a><a name="defaultTyVar"></a><span class='hs-comment'>------------------</span>
<a name="line-2"></a><span class='hs-definition'>defaultTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcsUntouchables</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-3"></a><span class='hs-comment'>-- defaultTyVar is used on any un-instantiated meta type variables to</span>
<a name="line-4"></a><span class='hs-comment'>-- default the kind of OpenKind and ArgKind etc to *.  This is important to</span>
<a name="line-5"></a><span class='hs-comment'>-- ensure that instance declarations match.  For example consider</span>
<a name="line-6"></a><span class='hs-comment'>--	instance Show (a-&gt;b)</span>
<a name="line-7"></a><span class='hs-comment'>--	foo x = show (\_ -&gt; True)</span>
<a name="line-8"></a><span class='hs-comment'>-- Then we'll get a constraint (Show (p -&gt;q)) where p has kind ArgKind, </span>
<a name="line-9"></a><span class='hs-comment'>-- and that won't match the typeKind (*) in the instance decl.  </span>
<a name="line-10"></a><span class='hs-comment'>-- See test tc217.</span>
<a name="line-11"></a><span class='hs-comment'>--</span>
<a name="line-12"></a><span class='hs-comment'>-- We look only at touchable type variables. No further constraints</span>
<a name="line-13"></a><span class='hs-comment'>-- are going to affect these type variables, so it's time to do it by</span>
<a name="line-14"></a><span class='hs-comment'>-- hand.  However we aren't ready to default them fully to () or</span>
<a name="line-15"></a><span class='hs-comment'>-- whatever, because the type-class defaulting rules have yet to run.</span>
<a name="line-16"></a>
<a name="line-17"></a><span class='hs-definition'>defaultTyVar</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>the_tv</span> 
<a name="line-18"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTouchableMetaTyVar_InRange</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>the_tv</span>
<a name="line-19"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varop'>`eqKind`</span> <span class='hs-varid'>default_k</span><span class='hs-layout'>)</span>
<a name="line-20"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tryTcS</span> <span class='hs-varop'>$</span> <span class='hs-comment'>-- Why tryTcS? See Note [tryTcS in defaulting]</span>
<a name="line-21"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CtLoc</span> <span class='hs-conid'>DefaultOrigin</span> <span class='hs-layout'>(</span><span class='hs-varid'>getSrcSpan</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-comment'>-- Yuk</span>
<a name="line-22"></a>             <span class='hs-varid'>fl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Wanted</span> <span class='hs-varid'>loc</span>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>eqv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcSMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>newKindConstraint</span> <span class='hs-varid'>the_tv</span> <span class='hs-varid'>default_k</span> <span class='hs-varid'>fl</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isNewEvVar</span> <span class='hs-varid'>eqv</span> <span class='hs-keyword'>then</span> 
<a name="line-25"></a>             <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>eqv</span>
<a name="line-26"></a>                                             <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-27"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-varid'>emptyBag</span> <span class='hs-layout'>}</span>
<a name="line-28"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>            
<a name="line-29"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>emptyBag</span>	 <span class='hs-comment'>-- The common case</span>
<a name="line-30"></a>  <span class='hs-keyword'>where</span>
<a name="line-31"></a>    <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>the_tv</span>
<a name="line-32"></a>    <span class='hs-varid'>default_k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultKind</span> <span class='hs-varid'>k</span>
<a name="line-33"></a>
<a name="line-34"></a>
<a name="line-35"></a><a name="findDefaultableGroups"></a><span class='hs-comment'>----------------</span>
<a name="line-36"></a><span class='hs-definition'>findDefaultableGroups</span> 
<a name="line-37"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span> <span class='hs-conid'>SimplContext</span> 
<a name="line-38"></a>       <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-39"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>  <span class='hs-comment'>-- (Overloaded strings, extended default rules)</span>
<a name="line-40"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcsUntouchables</span>	<span class='hs-comment'>-- Untouchable</span>
<a name="line-41"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>	<span class='hs-comment'>-- Unsolved</span>
<a name="line-42"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span><span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<a name="line-43"></a><span class='hs-definition'>findDefaultableGroups</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctxt</span><span class='hs-layout'>,</span> <span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span><span class='hs-layout'>,</span> <span class='hs-varid'>extended_defaults</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> 
<a name="line-44"></a>                      <span class='hs-varid'>untch</span> <span class='hs-varid'>wanteds</span>
<a name="line-45"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>performDefaulting</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-46"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>default_tys</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-47"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>is_defaultable_group</span> <span class='hs-layout'>(</span><span class='hs-varid'>equivClasses</span> <span class='hs-varid'>cmp_tv</span> <span class='hs-varid'>unaries</span><span class='hs-layout'>)</span>
<a name="line-48"></a>  <span class='hs-keyword'>where</span> 
<a name="line-49"></a>    <span class='hs-varid'>unaries</span>     <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- (C tv) constraints</span>
<a name="line-50"></a>    <span class='hs-varid'>non_unaries</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>             <span class='hs-comment'>-- and *other* constraints</span>
<a name="line-51"></a>    
<a name="line-52"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>unaries</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_unaries</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionWith</span> <span class='hs-varid'>find_unary</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-53"></a>        <span class='hs-comment'>-- Finds unary type-class constraints</span>
<a name="line-54"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-55"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-56"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-57"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>cc</span>  <span class='hs-comment'>-- Non unary or non dictionary </span>
<a name="line-58"></a>
<a name="line-59"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span>  <span class='hs-comment'>-- TyVars mentioned by non-unaries </span>
<a name="line-60"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionVarSet</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tyVarsOfCt</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>non_unaries</span> 
<a name="line-61"></a>
<a name="line-62"></a>    <span class='hs-varid'>cmp_tv</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>tv2</span>
<a name="line-63"></a>
<a name="line-64"></a>    <span class='hs-varid'>is_defaultable_group</span> <span class='hs-varid'>ds</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-65"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>b1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTyConableTyVar</span> <span class='hs-varid'>tv</span>	<span class='hs-comment'>-- Note [Avoiding spurious errors]</span>
<a name="line-66"></a>              <span class='hs-varid'>b2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span>
<a name="line-67"></a>              <span class='hs-varid'>b3</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTouchableMetaTyVar_InRange</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>tv</span> 
<a name="line-68"></a>              <span class='hs-varid'>b4</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultable_classes</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>cc_class</span> <span class='hs-varid'>cc</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ds</span><span class='hs-keyglyph'>]</span>
<a name="line-69"></a>          <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>b1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b3</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b4</span><span class='hs-layout'>)</span>
<a name="line-70"></a>          <span class='hs-comment'>{- pprTrace "is_defaultable_group" (vcat [ text "isTyConable   " &lt;+&gt; ppr tv &lt;+&gt; ppr b1 
<a name="line-71"></a>                                                   , text "is not in bad " &lt;+&gt; ppr tv &lt;+&gt; ppr b2 
<a name="line-72"></a>                                                   , text "is touchable  " &lt;+&gt; ppr tv &lt;+&gt; ppr b3
<a name="line-73"></a>                                                   , text "is defaultable" &lt;+&gt; ppr tv &lt;+&gt; ppr b4 ]) -}</span>
<a name="line-74"></a>    <span class='hs-varid'>is_defaultable_group</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"defaultable_group"</span>
<a name="line-75"></a>
<a name="line-76"></a>    <span class='hs-varid'>defaultable_classes</span> <span class='hs-varid'>clss</span> 
<a name="line-77"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>extended_defaults</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>clss</span>
<a name="line-78"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>clss</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>clss</span><span class='hs-layout'>)</span>
<a name="line-79"></a>
<a name="line-80"></a>    <span class='hs-comment'>-- In interactive mode, or with -XExtendedDefaultRules,</span>
<a name="line-81"></a>    <span class='hs-comment'>-- we default Show a to Show () to avoid graututious errors on "show []"</span>
<a name="line-82"></a>    <span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>cls</span> 
<a name="line-83"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>classKey</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>showClassKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqClassKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>ordClassKey</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-84"></a>
<a name="line-85"></a>    <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNumericClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-86"></a>    <span class='hs-comment'>-- is_num_class adds IsString to the standard numeric classes, </span>
<a name="line-87"></a>    <span class='hs-comment'>-- when -foverloaded-strings is enabled</span>
<a name="line-88"></a>
<a name="line-89"></a>    <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStandardClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-90"></a>    <span class='hs-comment'>-- Similarly is_std_class</span>
<a name="line-91"></a>
<a name="line-92"></a><a name="disambigGroup"></a><span class='hs-comment'>------------------------------</span>
<a name="line-93"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>           <span class='hs-comment'>-- The default types </span>
<a name="line-94"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- All classes of the form (C a)</span>
<a name="line-95"></a>	      	 		  <span class='hs-comment'>--  sharing same type variable</span>
<a name="line-96"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-97"></a>
<a name="line-98"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-conid'>[]</span>  <span class='hs-sel'>_grp</span>
<a name="line-99"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>emptyBag</span>
<a name="line-100"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_ty</span><span class='hs-conop'>:</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>group</span>
<a name="line-101"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>group</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-102"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>success</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryTcS</span> <span class='hs-varop'>$</span> <span class='hs-comment'>-- Why tryTcS? See Note [tryTcS in defaulting]</span>
<a name="line-103"></a>                    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>der_flav</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_derived_flavor</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc_flavor</span> <span class='hs-varid'>the_ct</span><span class='hs-layout'>)</span> 
<a name="line-104"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>derived_eq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryTcS</span> <span class='hs-varop'>$</span>
<a name="line-105"></a>                                       <span class='hs-comment'>-- I need a new tryTcS because we will call solveInteractCts below!</span>
<a name="line-106"></a>                                       <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>eqv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcSMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>newEqVar</span> <span class='hs-varid'>der_flav</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>default_ty</span>
<a name="line-107"></a>                                          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evc_the_evvar</span> <span class='hs-varid'>eqv</span>
<a name="line-108"></a>                                                                   <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>der_flav</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>
<a name="line-109"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup (solving) {"</span> 
<a name="line-110"></a>                                  <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"trying to solve constraints along with default equations ..."</span><span class='hs-layout'>)</span> 
<a name="line-111"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-layout'>(</span><span class='hs-varid'>derived_eq</span> <span class='hs-varop'>++</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-112"></a>                       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>unsolved</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>extractUnsolvedTcS</span> 
<a name="line-113"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup (solving) }"</span>
<a name="line-114"></a>                                  <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"disambigGroup unsolved ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>keepWanted</span> <span class='hs-varid'>unsolved</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-115"></a>                       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>keepWanted</span> <span class='hs-varid'>unsolved</span><span class='hs-layout'>)</span> <span class='hs-keyword'>then</span> <span class='hs-comment'>-- Don't care about Derived's</span>
<a name="line-116"></a>                             <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varop'>$</span> <span class='hs-varid'>listToBag</span> <span class='hs-varid'>derived_eq</span><span class='hs-layout'>)</span> 
<a name="line-117"></a>                         <span class='hs-keyword'>else</span> 
<a name="line-118"></a>                             <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span> 
<a name="line-119"></a>                       <span class='hs-layout'>}</span>
<a name="line-120"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>success</span> <span class='hs-keyword'>of</span>
<a name="line-121"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Success: record the type variable binding, and return</span>
<a name="line-122"></a>                    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wrapWarnTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>warnDefaulting</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>default_ty</span>
<a name="line-123"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup succeeded"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-124"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>cts</span> <span class='hs-layout'>}</span>
<a name="line-125"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Failure: try with the next type</span>
<a name="line-126"></a>                    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup failed, will try other default types"</span>
<a name="line-127"></a>                                  <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-128"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span> <span class='hs-varid'>group</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-129"></a>  <span class='hs-keyword'>where</span>
<a name="line-130"></a>    <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>the_ct</span><span class='hs-layout'>,</span><span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>group</span>
<a name="line-131"></a>    <span class='hs-varid'>wanteds</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>group</span>
<a name="line-132"></a>    <span class='hs-varid'>mk_derived_flavor</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtFlavor</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavor</span>
<a name="line-133"></a>    <span class='hs-varid'>mk_derived_flavor</span> <span class='hs-layout'>(</span><span class='hs-conid'>Wanted</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Derived</span> <span class='hs-varid'>loc</span>
<a name="line-134"></a>    <span class='hs-varid'>mk_derived_flavor</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"Asked  to disambiguate given or derived!"</span>
</pre>\end{code}

Note [Avoiding spurious errors]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When doing the unification for defaulting, we check for skolem
type variables, and simply don't default them.  For example:
   f = (*)	-- Monomorphic
   g :: Num a => a -> a
   g x = f x x
Here, we get a complaint when checking the type signature for g,
that g isn't polymorphic enough; but then we get another one when
dealing with the (Num a) context arising from f's definition;
we try to unify a with Int (to default it), but find that it's
already been unified with the rigid variable from g's type sig



*********************************************************************************
*                                                                               * 
*                   Utility functions
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="newFlatWanteds"></a><span class='hs-definition'>newFlatWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtOrigin</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a><span class='hs-definition'>newFlatWanteds</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>theta</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getCtLoc</span> <span class='hs-varid'>orig</span>
<a name="line-4"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>inst_to_wanted</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span> <span class='hs-varid'>theta</span> <span class='hs-layout'>}</span>
<a name="line-5"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>inst_to_wanted</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>pty</span> 
<a name="line-6"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWantedEvVar</span> <span class='hs-varid'>pty</span> 
<a name="line-7"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-8"></a>                 <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span>
<a name="line-9"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>cc_flavor</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Wanted</span> <span class='hs-varid'>loc</span>
<a name="line-10"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
</pre>\end{code}</body>
</html>
